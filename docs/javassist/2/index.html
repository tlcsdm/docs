<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="generator" content="Aspose.Words for .NET 23.1.0" /><title></title><style type="text/css">body { font-family:Calibri; font-size:11pt }h2, h3, h4, p { margin:0pt 0pt 8pt }li, table { margin-top:0pt; margin-bottom:8pt }h2 { margin-top:12pt; margin-bottom:3pt; page-break-after:avoid; font-family:Arial; font-size:14pt; font-weight:bold; font-style:italic }h3 { margin-top:12pt; margin-bottom:3pt; page-break-after:avoid; font-family:Arial; font-size:13pt; font-weight:bold }h4 { margin-top:12pt; margin-bottom:3pt; page-break-after:avoid; font-size:14pt; font-weight:bold }.IndentedCode { margin-bottom:8pt; font-family:Consolas; font-size:10pt; background-color:#e2e2e2 }.Quote { margin-bottom:8pt; border-left:2.25pt solid #9f9f9f; font-size:11pt; font-style:italic; color:#000000 }span.QuoteChar { font-size:12pt; font-style:italic; color:#000000 }</style></head><body><div><h2><span style="font-family:Calibri; font-weight:normal; font-style:normal">一、读写字节码</span></h2><h3><span style="font-weight:normal">1. </span><span style="font-family:Calibri; font-weight:normal">获取类文件对象</span><span style="font-weight:normal">CtClass</span></h3><p><span>Javassist是一个用于处理Java字节码的库。Java字节码存储在一个class结尾的二进制文件中。每一个class文件都包含了一个Java类或接口。</span></p><p><span style="font-weight:bold">javassist.CtClass</span><span>是class文件的一个抽象代表。一个</span><span style="font-weight:bold">CtClass</span><span>（编译期类）对象处理一个class文件。例如：</span></p><p class="IndentedCode"><span>// 见chapter.one.Test1</span><br /><span>ClassPool pool = ClassPool.getDefault();</span><br /><span>CtClass cc = pool.get("test.Rectangle");</span><br /><span>cc.setSuperclass(pool.get("test.Point"));</span><br /><span>cc.writeFile();</span></p><p><span>这个程序首先定义了个</span><span style="font-weight:bold">ClassPool</span><span>对象，它控制着字节码的修改。</span><span style="font-weight:bold">ClassPool</span><span>对象是</span><span style="font-weight:bold">CtClass</span><span>对象的一个容器，它代表一个Class文件。它会读取Class（test.Rectangle）文件，然后构造一个</span><span style="font-weight:bold">CtClass</span><span>对象。为了修改一个类，用户必须用</span><span style="font-weight:bold">ClassPool</span><span>对象的</span><span style="font-weight:bold">get()方法来获取CtClass</span><span>对象。上面展示的例子中，</span><span style="font-weight:bold">CtClass</span><span>的实例</span><span style="font-weight:bold">cc</span><span>代表类</span><span style="font-weight:bold">test.Rectanle</span><span>。</span><span style="font-weight:bold">ClassPool</span><span>实例通过 </span><span style="font-weight:bold">getDefault()</span><span> 方法实例化，它采用默认的搜索路径方式。</span></p><p><span>从实现的角度看，</span><span style="font-weight:bold">ClassPool</span><span>是</span><span style="font-weight:bold">CtClass</span><span>对象的一个Hash表，</span><span style="font-weight:bold">ClassPool</span><span>使用类名作为键。当使用</span><span style="font-weight:bold">classPool.get()</span><span> 方法时，会搜索Hash表，根据类名找出相应的</span><span style="font-weight:bold">CtClass</span><span>对象。如果该对象没找到，就会读取类文件，然后构造一个</span><span style="font-weight:bold">CtClass</span><span>对象，将其存到Hash表中，并返回结果。</span></p><p><span style="font-weight:bold">CtClass</span><span>对象可以被修改（第四章会详细介绍）。上面的例子中，它将</span><span style="font-weight:bold">test.Point</span><span>作为自己的父类。在调用</span><span style="font-weight:bold">writeFile()</span><span> 后，该修改就会反映到源class文件中。</span></p><h3><span style="font-weight:normal">2. </span><span style="font-family:Calibri; font-weight:normal">获取字节码</span></h3><p><span style="font-weight:bold">writeFile()</span><span> 将</span><span style="font-weight:bold">CtClass</span><span>对象转化为一个Class文件，并把它写到本地磁盘上。Javassist也提供了一个方法，用于直接获取被修改的字节码。可以调用</span><span style="font-weight:bold">toBytecode()</span><span> 方法获取：</span></p><p class="IndentedCode"><span>byte[] b = cc.toBytecode();</span></p><p><span>你也可以直接加载</span><span style="font-weight:bold">CtClass</span><span>:</span></p><p class="IndentedCode"><span>Class clazz = cc.toClass();</span></p><p><span style="font-weight:bold">toClass()</span><span> 请求当前线程的上下文类加载器来加载</span><span style="font-weight:bold">CtClass</span><span>代表的class文件，它返回</span><span style="font-weight:bold">java.lang.Class</span><span>对象。更多细节见第三章。</span></p><h3><span style="font-weight:normal">3. </span><span style="font-family:Calibri; font-weight:normal">定义一个新的类</span></h3><p><span>要定义一个新的类，必须使用</span><span style="font-weight:bold">ClassPool</span><span>对象，调用其</span><span style="font-weight:bold">makeClass()</span><span> 方法：</span></p><p class="IndentedCode"><span>ClassPool pool = ClassPool.getDefault();</span><br /><span>CtClass cc = pool.makeClass("Point");</span></p><p><span>这段代码定义了一个类名为</span><span style="font-weight:bold">Point</span><span>的类，它没有任何成员。</span><span style="font-weight:bold">Point</span><span>的成员方法可以通过声明在</span><span style="font-weight:bold">CtNewMethod</span><span>中的工厂方法来创建，使用</span><span style="font-weight:bold">CtClass</span><span>中的</span><span style="font-weight:bold">addMethod()</span><span> 方法可以实现。</span></p><p><span style="font-weight:bold">makeClass()</span><span> 不能创建一个新的接口，需要用</span><span style="font-weight:bold">makeInterface()</span><span>。接口的成员方法是使用</span><span style="font-weight:bold">CtNewMethod</span><span>的</span><span style="font-weight:bold">abstractMethod()</span><span> 。注意接口的方法是抽象方法。</span></p><h3><span style="font-weight:normal">4. </span><span style="font-family:Calibri; font-weight:normal">冻结类</span></h3><p><span>如果一个</span><span style="font-weight:bold">CtClass</span><span>对象已经转化成了class文件，比如通过</span><span style="font-weight:bold">writeFile()</span><span> 、</span><span style="font-weight:bold">toClass()</span><span> 、 </span><span style="font-weight:bold">toBytecode()</span><span> , Javassist会冻结</span><span style="font-weight:bold">CtClass</span><span>对象。之后对于</span><span style="font-weight:bold">CtClass</span><span>对象的修改都是不允许的。这个是为了警告开发者，他们尝试修改的Class文件已经被加载了，JVM不允许再次加载该Class。</span></p><p><span>冻结的类可以如果想要修改，可以进行解冻，这样就允许修改了，如下：</span></p><p class="IndentedCode"><span>CtClasss cc = ...;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>:</span><br /><span>cc.writeFile();</span><span style="-aw-import:spaces">&#xa0; </span><span>// 会引起类冻结</span><br /><span>cc.defrost();</span><span style="-aw-import:spaces">&#xa0;&#xa0; </span><span>// 解冻</span><br /><span>cc.setSuperclass(...);</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// OK 因为这个类已经被解冻了</span></p><p><span>在</span><span style="font-weight:bold">defrost()</span><span> 被调用之后，该</span><span style="font-weight:bold">CtClass</span><span>对象可以再次被修改。</span></p><p><span>如果</span><span style="font-weight:bold">ClassPool.doPruning</span><span>被设置为true，当</span><span style="font-weight:bold">CtClass</span><span>被冻结时，Javassist会修剪它的数据结构。为了减少内存消耗，会删除那个对象中不需要的属性(attribute_info structures)。例如，Code_attribute结构(方法体)会被删除。因此，在</span><span style="font-weight:bold">CtClass</span><span>对象被修剪之后，方法的字节码是不可访问的，除了方法名称，签名和注释（我也不知道这里的annotations指的是注解还是注释）。被修剪的</span><span style="font-weight:bold">CtClass</span><span>对象不能再次被解冻（defrost）。</span><span style="font-weight:bold">ClassPool.doPruning</span><span> 的默认是false.</span></p><p class="IndentedCode"><span>CtClasss cc = ...;</span><br /><span>cc.stopPruning(true);</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>:</span><br /><span>cc.writeFile();</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>// 转化为一个Class文件</span><br /><span>// cc 没有被修剪.</span></p><p><span>该</span><span style="font-weight:bold">CtClass</span><span>对象</span><span style="font-weight:bold">cc</span><span>没有被修剪。因此它还可以在调用</span><span style="font-weight:bold">writeFile()</span><span> 之后调用</span><span style="font-weight:bold">defrost()</span><span> 解冻。</span></p><p class="Quote"><span style="font-style:normal">在Debug的时候，你可能想暂停修剪和冻结，然后把修改后的class文件写到磁盘上, 可以使用**debugWriteFile()**方法来达到目的。 它会停止修剪，然后写Class文件,并且再次开始修剪（如果一开始就开始修剪的话）。</span></p><h3><span style="font-weight:normal">5. </span><span style="font-family:Calibri; font-weight:normal">类路径搜索</span></h3><p><span style="font-weight:bold">ClassPool.getDefault</span><span> 默认会搜索JVM下面相同路径的类，并返回ClassPool。但是，如果一个程序运行在Web应用服务器上，像JBoss和Tomcat那种，</span><span style="font-weight:bold">ClassPool</span><span>对象可能就找不到用户指定的类了，因为web应用服务使用了多个系统类加载器。这种情况下，需要给</span><span style="font-weight:bold">ClassPool</span><span>注册一个额外的Class路径。如下：</span></p><p class="IndentedCode"><span>pool.insertClassPath(new ClassClassPath(this.getClass()));</span><span style="-aw-import:spaces">&#xa0; </span><span>// 假设pool是ClassPool的一个实例</span></p><p><span>这句代码注册了一个类的类路径，这个类是</span><span style="font-weight:bold">this</span><span>指向的那个类。你可以使用任意</span><span style="font-weight:bold">Class</span><span>代替</span><span style="font-weight:bold">this.getClass()</span><span>。</span></p><p><span>你也可以注册一个文件夹作为类路径。例如，下面这段代码增添可以了文件夹**/usr/local/javalib**到搜索路径中：</span></p><p class="IndentedCode"><span>ClassPool pool = ClassPool.getDefault();</span><br /><span>pool.insertClassPath("/usr/local/javalib");</span></p><p><span>搜索路径不仅可以是目录，甚至可以是URL：</span></p><p class="IndentedCode"><span>ClassPool pool = ClassPool.getDefault();</span><br /><span>ClassPath cp = new URLClassPath("www.javassist.org", 80, "/java/", "org.javassist.");</span><br /><span>pool.insertClassPath(cp);</span></p><p><span>该代码增添了</span><span style="font-weight:bold">http://www.javassist.org:80/java/</span><span> 到类文件搜索路径下。该URL仅仅搜索</span><span style="font-weight:bold">org.javassist.</span><span> 包下的class文件。例如，要加载</span><span style="font-weight:bold">org.javassist.test.Main</span><span> 这个类，javassist会从这个地址下获取该类文件：</span></p><p class="IndentedCode"><span>http://www.javassist.org:80/java/org/javassist/test/Main.class</span></p><p><span>此外，你也可以直接给</span><span style="font-weight:bold">ClassPool</span><span>对象一个byte数组，然后用这个数组构建</span><span style="font-weight:bold">CtClass</span><span>对象。要这样做，用</span><span style="font-weight:bold">ByteArrayClassPath</span><span>, 例如：</span></p><p class="IndentedCode"><span>ClassPool cp = ClassPool.getDefault();</span><br /><span>byte[] b = a byte array;</span><br /><span>String name = class name;</span><br /><span>cp.insertClassPath(new ByteArrayClassPath(name, b));</span><br /><span>CtClass cc = cp.get(name);</span></p><p><span>获得的</span><span style="font-weight:bold">CtClass</span><span>对象表示一个由</span><span style="font-weight:bold">b</span><span>指定的类文件定义的类。如果调用</span><span style="font-weight:bold">get()</span><span> ，</span><span style="font-weight:bold">ClassPool</span><span>会从</span><span style="font-weight:bold">ByteArrayClassPath</span><span>中读取一个Class文件，指定的Class的名字就是上面的</span><span style="font-weight:bold">name</span><span>变量。</span></p><p><span>如果你不知道这个类的全限定名，你你可以使用</span><span style="font-weight:bold">ClassPool</span><span>中的</span><span style="font-weight:bold">makeClass()</span><span> :</span></p><p class="IndentedCode"><span>ClassPool cp = ClassPool.getDefault();</span><br /><span>InputStream ins = an input stream for reading a class file;</span><br /><span>CtClass cc = cp.makeClass(ins);</span></p><p><span style="font-weight:bold">makeClass()</span><span> 返回一个通过输入流构建出来的</span><span style="font-weight:bold">CtClass</span><span>。你可以使用</span><span style="font-weight:bold">makeClass()</span><span> 给</span><span style="font-weight:bold">ClassPool</span><span> 对象提供一个比较急的Class文件。如果搜索路径包含了一个很大的jar包，这可以提高性能。因为</span><span style="font-weight:bold">ClassPool</span><span>对象会一个一个找，它可能会重复搜索整个jar包中的每一个class文件。</span><span style="font-weight:bold">makeClass()</span><span> 可以优化这个搜索。</span><span style="font-weight:bold">makeClass()构造出来的类会保存在ClassPool</span><span>对象中，你下次再用的时候，不会再次读Class文件。</span></p><h2><span style="font-family:Calibri; font-weight:normal; font-style:normal">二、</span><span style="font-weight:normal; font-style:normal">ClassPool</span><span style="font-family:Calibri; font-weight:normal; font-style:normal">详解</span></h2><h3><span style="font-weight:normal">1. ClassPool</span><span style="font-family:Calibri; font-weight:normal">简介</span></h3><p><span style="font-weight:bold">ClassPool</span><span>对象是多个</span><span style="font-weight:bold">CtClass</span><span>对象的容器。一旦</span><span style="font-weight:bold">CtClass</span><span>对象被创建，它就会永远被记录再</span><span style="font-weight:bold">ClassPool</span><span>对象中。这是因为编译器之后在编译源码的时候可能需要访问</span><span style="font-weight:bold">CtClass</span><span>对象。</span></p><p><span>例如，假定有一个新方法</span><span style="font-weight:bold">getter()</span><span> 被增添到了表示</span><span style="font-weight:bold">Point</span><span>类的</span><span style="font-weight:bold">CtClass</span><span>对象。稍后，程序会试图编译代码，它包含了对</span><span style="font-weight:bold">Point</span><span>方法的</span><span style="font-weight:bold">getter()</span><span> 调用，并会使用编译后代码作为一个方法的方法体，它将会被增添到另一个类</span><span style="font-weight:bold">Line</span><span>中。如果表示</span><span style="font-weight:bold">Point</span><span>类的</span><span style="font-weight:bold">CtClass</span><span>对象丢了的话，编译器就不能编译调用</span><span style="font-weight:bold">getter()</span><span> 的方法了（注意：原始类定义中不包含</span><span style="font-weight:bold">getter()</span><span> ）。因此，为了正确编译这样一个方法调用，</span><span style="font-weight:bold">ClassPool</span><span>在程序过程中必须示种包含所有的</span><span style="font-weight:bold">CtClass</span><span>对象。</span></p><p class="IndentedCode"><span>ClassPool classPool = ClassPool.getDefault();</span><br /><span>CtClass point = classPool.makeClass("Point");</span><br /><span>point.addMethod(getterMethod);</span><span style="-aw-import:spaces">&#xa0; </span><span>// Point增添了getter方法</span><br /><span>CtClass line = ...; // Line方法</span><br /><span>// line 调用point的getter方法</span></p><h3><span style="font-weight:normal">2. </span><span style="font-family:Calibri; font-weight:normal">避免内存溢出</span></h3><p><span>某种特定的</span><span style="font-weight:bold">ClassPool</span><span>可能造成巨大的内存消耗，导致OOM，比如</span><span style="font-weight:bold">CtClass</span><span>对象变得非常的（这个发生的很少，因为Javassist已经尝试用不同的方法减少内存消耗了，比如冻结类）。为了避免该问题，你可以从</span><span style="font-weight:bold">ClassPool</span><span>中移除不需要的</span><span style="font-weight:bold">CtClass</span><span>对象。只需要调用</span><span style="font-weight:bold">CtClass</span><span>的</span><span style="font-weight:bold">detach()</span><span> 方法就行了：</span></p><p class="IndentedCode"><span>CtClass cc = ... ;</span><br /><span>cc.writeFile();</span><br /><span>cc.detach();</span><span style="-aw-import:spaces">&#xa0; </span><span>// 该CtClass已经不需要了，从ClassPool中移除</span></p><p><span>在调用</span><span style="font-weight:bold">detach()</span><span> 之后，这个</span><span style="font-weight:bold">CtClass</span><span>对象就不能再调用任何方法了。但是你可以依然可以调用</span><span style="font-weight:bold">classPool.get()</span><span> 方法来创建一个相同的类。如果你调用</span><span style="font-weight:bold">get()</span><span> ，</span><span style="font-weight:bold">ClassPool</span><span>会再次读取class文件，然后创建一个新的</span><span style="font-weight:bold">CtClass</span><span>对象并返回。</span></p><p><span>另一种方式是new一个新的</span><span style="font-weight:bold">ClassPool</span><span>,旧的就不要了。这样旧的</span><span style="font-weight:bold">ClassPool</span><span>就会被垃圾回收，它的</span><span style="font-weight:bold">CtClass</span><span>也会被跟着垃圾回收。可以使用以下代码完成：</span></p><p class="IndentedCode"><span>ClassPool cp = new ClassPool(true);</span><span style="-aw-import:spaces">&#xa0; </span><span>// true代表使用默认路径</span><br /><span>// 如果需要的话，可以用appendClassPath()添加一个额外的搜索路径。</span></p><p><span>上面这个</span><span style="font-weight:bold">new ClassPool</span><span>和</span><span style="font-weight:bold">ClassPool.getDefault()</span><span> 的效果是一样。注意，</span><span style="font-weight:bold">ClassPool.getDefault()</span><span> 是一个单例的工厂方法，它只是为了方便用户创建提供的方法。这两种创建方式是一样的，源码也基本是一样的，只不过**ClassPool.getDefault()**是单例的。</span></p><p><span>注意，</span><span style="font-weight:bold">new ClassPool(true)</span><span> 是一个很方便的构造函数，它构造了一个</span><span style="font-weight:bold">ClassPool</span><span>对象，然后给他增添了系统搜索路径。它构造方法的调用就等同于下面的这段代码：</span></p><p class="IndentedCode"><span>ClassPool cp = new ClassPool();</span><br /><span>cp.appendSystemPath();</span><span style="-aw-import:spaces">&#xa0; </span><span>// 你也可以通过appendClassPath()增添其他路径</span></p><h3><span style="font-weight:normal">3. </span><span style="font-family:Calibri; font-weight:normal">级联</span><span style="font-weight:normal">ClassPool</span></h3><p><span>如果一个程序运行在Web应用服务器上，你可能需要创建多个</span><span style="font-weight:bold">ClassPool</span><span>实例。为每一个类加载器（ClassLoader）创建一个</span><span style="font-weight:bold">ClassPool</span><span>（也就是容器）。这时程序在创建</span><span style="font-weight:bold">ClassPool</span><span>对象的时候就不能再用</span><span style="font-weight:bold">getDefault()</span><span> 了，而是要用</span><span style="font-weight:bold">ClassPool</span><span>的构造函数。</span></p><p><span>多个</span><span style="font-weight:bold">ClassPool</span><span>对象可以像</span><span style="font-weight:bold">java.lang.ClassLoader</span><span>那样进行级联。例如：</span></p><p class="IndentedCode"><span>ClassPool parent = ClassPool.getDefault();</span><br /><span>ClassPool child = new ClassPool(parent);</span><br /><span>child.insertClassPath("./classes");</span></p><p><span>如果调用了</span><span style="font-weight:bold">child.get()</span><span> ，child的</span><span style="font-weight:bold">ClassPool</span><span>首先会代理parent的</span><span style="font-weight:bold">ClassPool</span><span>，如果parent的</span><span style="font-weight:bold">ClassPool</span><span>中没有找到要找的类，才会试图到child中的**./classes**目录下找。</span></p><p><span>如果</span><span style="font-weight:bold">child.childFirstLookup</span><span>设置为了true，child的</span><span style="font-weight:bold">ClassPool</span><span>就会首先到自己路径下面找，之后才会到parent的路径下面找。</span></p><p class="IndentedCode"><span>ClassPool parent = ClassPool.getDefault();</span><br /><span>ClassPool child = new ClassPool(parent);</span><br /><span>child.appendSystemPath();</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>// 这默认使用相同的类路径</span><br /><span>child.childFirstLookup = true;</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// 改变child的行为。</span></p><h3><span style="font-weight:normal">4. </span><span style="font-family:Calibri; font-weight:normal">更改类名的方式定义新类</span></h3><p><span>一个“新类”可以从一个已经存在的类copy出来。可以使用以下代码：</span></p><p class="IndentedCode"><span>ClassPool pool = ClassPool.getDefault();</span><br /><span>CtClass cc = pool.get("Point");</span><br /><span>cc.setName("Pair");</span></p><p><span>这段代码首先获取了</span><span style="font-weight:bold">Point</span><span>的</span><span style="font-weight:bold">CtClass</span><span>对象。然后调用</span><span style="font-weight:bold">setName()</span><span> 方法给对象一个新的名字</span><span style="font-weight:bold">Pair</span><span>。在这个调用之后，</span><span style="font-weight:bold">CtClass</span><span>表示的类中的所有</span><span style="font-weight:bold">Point</span><span>都会替换为</span><span style="font-weight:bold">Pair</span><span>。类定义的其他部分不会变。</span></p><p><span>既然</span><span style="font-weight:bold">setName()</span><span> 改变了</span><span style="font-weight:bold">ClassPool</span><span>对象中的记录。从实现的角度看，</span><span style="font-weight:bold">ClassPool</span><span>是一个hash表，</span><span style="font-weight:bold">setName()</span><span> 改变了关联这个</span><span style="font-weight:bold">CtClass</span><span>对象的</span><span style="font-weight:bold">key</span><span>值。这个</span><span style="font-weight:bold">key</span><span>值从原名称</span><span style="font-weight:bold">Point</span><span>变为了新名称</span><span style="font-weight:bold">Pair</span><span>。</span></p><p><span>因此，如果之后调用</span><span style="font-weight:bold">get("Point")</span><span> ，就不会再返回上面的</span><span style="font-weight:bold">cc</span><span>引用的对象了。</span><span style="font-weight:bold">ClassPool</span><span>对象会再次读取class文件，然后构造一个新的</span><span style="font-weight:bold">CtClass</span><span>对象。这是因为</span><span style="font-weight:bold">Point</span><span>这个</span><span style="font-weight:bold">CtClass</span><span>在</span><span style="font-weight:bold">ClassPool</span><span>中已经不存在了。请看下面代码：</span></p><p class="IndentedCode"><span>ClassPool pool = ClassPool.getDefault();</span><br /><span>CtClass cc = pool.get("Point");</span><br /><span>CtClass cc1 = pool.get("Point");</span><span style="-aw-import:spaces">&#xa0;&#xa0; </span><span>// 此时，cc1和cc是完全一样的。</span><br /><span>cc.setName("Pair");</span><br /><span>CtClass cc2 = pool.get("Pair");</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// cc2和cc是完全一样的</span><br /><span>CtClass cc3 = pool.get("Point");</span><span style="-aw-import:spaces">&#xa0;&#xa0; </span><span>// cc3和cc是不一样的，因为cc3是重新读取的class文件</span></p><p><span style="font-weight:bold">cc1</span><span>和</span><span style="font-weight:bold">cc2</span><span>引用的是相同的实例，和</span><span style="font-weight:bold">cc</span><span>指向的是同一地址。但是，</span><span style="font-weight:bold">cc3</span><span>却不是。注意，在执行</span><span style="font-weight:bold">cc.setName("Pair")</span><span> 之后，</span><span style="font-weight:bold">cc</span><span>和</span><span style="font-weight:bold">cc1</span><span>引用的是同一地址，所以它们的</span><span style="font-weight:bold">CtClass</span><span>都是代表</span><span style="font-weight:bold">Pair</span><span>类。</span></p><p><span style="font-weight:bold">ClassPool</span><span>对象用于维护</span><span style="font-weight:bold">CtClass</span><span>对象和类之间的一一映射关系。Javassist不允许两个不同的</span><span style="font-weight:bold">CtClass</span><span>对象代表相同的类，除非你用两个</span><span style="font-weight:bold">ClassPool</span><span>。这个是程序转换一致性的重要特性。</span></p><p><span>要创建</span><span style="font-weight:bold">ClassPool</span><span>的副本，可以使用下面的代码片段（这个上面已经提到过了）：</span></p><p class="IndentedCode"><span>ClassPool cp = new ClassPool(true);</span></p><p><span>如果你又两个</span><span style="font-weight:bold">ClassPool</span><span>对象，那么你就可以从这两个对象中获取到相同class文件但是不同的</span><span style="font-weight:bold">CtClass</span><span>对象。你可以对那两个</span><span style="font-weight:bold">CtClass</span><span>进行不同方式的修改，然后生成两个版本的Class。</span></p><h3><span style="font-weight:normal">5. </span><span style="font-family:Calibri; font-weight:normal">重命名冻结类的方式定义新类</span></h3><p><span>一旦</span><span style="font-weight:bold">CtClass</span><span>对象转化为Class文件后，比如</span><span style="font-weight:bold">writeFile()</span><span> 或是 </span><span style="font-weight:bold">toBytecode()</span><span> 之后，Javassist会拒绝</span><span style="font-weight:bold">CtClass</span><span>对象进一步的修改。因此，在</span><span style="font-weight:bold">CtClass</span><span>对象转为文件之后，你将不能再通过</span><span style="font-weight:bold">setNme()</span><span> 的方式将该类拷贝成一个新的类了。比如，下面的这段错误代码：</span></p><p class="IndentedCode"><span>ClassPool pool = ClassPool.getDefault();</span><br /><span>CtClass cc = pool.get("Point");</span><br /><span>cc.writeFile();</span><br /><span>cc.setName("Pair");</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// 错， 因为cc已经调用了writeFile()</span></p><p><span>为了解除这个限制，你应该调用</span><span style="font-weight:bold">ClassPool</span><span> 的 </span><span style="font-weight:bold">getAndRename()</span><span> 方法。 例如：</span></p><p class="IndentedCode"><span>ClassPool pool = ClassPool.getDefault();</span><br /><span>CtClass cc = pool.get("Point");</span><br /><span>cc.writeFile();</span><br /><span>CtClass cc2 = pool.getAndRename("Point", "Pair"); </span></p><p><span>如果调用了</span><span style="font-weight:bold">getAndRename</span><span>，</span><span style="font-weight:bold">ClassPool</span><span>首先为了创建代表</span><span style="font-weight:bold">Pair</span><span>的</span><span style="font-weight:bold">CtClass</span><span>而去读取</span><span style="font-weight:bold">Point.class</span><span>。然而，它在记录</span><span style="font-weight:bold">CtClass</span><span>到hash表之前，会把</span><span style="font-weight:bold">CtClass</span><span>由</span><span style="font-weight:bold">Point</span><span>重命名为</span><span style="font-weight:bold">Pair</span><span>。因此</span><span style="font-weight:bold">getAndRename()</span><span> 可以在</span><span style="font-weight:bold">writeFile()</span><span> 或 </span><span style="font-weight:bold">toBytecode()</span><span> 之后执行。</span></p><h2><span style="font-family:Calibri; font-weight:normal; font-style:normal">三、</span><span style="font-weight:normal; font-style:normal">Class loader</span><span style="font-family:Calibri; font-weight:normal; font-style:normal">详解</span></h2><p><span>如果一开始你就知道要修改哪个类，那么最简单的方式如下：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>1.调用</span><span style="font-weight:bold">ClassPool.get()</span><span> 来获取一个</span><span style="font-weight:bold">CtClass</span><span>对象。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>2.修改它</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>3.调用</span><span style="font-weight:bold">writeFile()</span><span> 或 </span><span style="font-weight:bold">toBytecode()</span><span> 来获取一个修改后的class文件</span></p><p><span>如果一个类是否要被修改是在加载时确定的，用户就必须让Javassist和类加载器协作。Javassist可以和类加载器一块儿使用，以便于可以在加载时修改字节码。用户可以自定义类加载器，也可以使用Javassist提供好的。</span></p><h3><span style="font-weight:normal">3.1. CtClass</span><span style="font-family:Calibri; font-weight:normal">的 </span><span style="font-weight:normal">toClass() </span><span style="font-family:Calibri; font-weight:normal">方法</span></h3><p><span style="font-weight:bold">CtClass</span><span>提供了一个方便的方法</span><span style="font-weight:bold">toClass()</span><span>, 它会请求当前线程的上下文类加载器，让其加载</span><span style="font-weight:bold">CtClass</span><span>对象所代表的那个类。要调用这个方法，必须要拥有权限。此外，该方法还会抛出</span><span style="font-weight:bold">SecurityException</span><span>异常。</span></p><p><span>使用</span><span style="font-weight:bold">toClass()</span><span> 方法样例：</span></p><p class="IndentedCode"><span>public class Hello {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public void say() {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>System.out.println("Hello");</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>}</span><br /><span>}</span><br /><br /><span>public class Test {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public static void main(String[] args) throws Exception {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>ClassPool cp = ClassPool.getDefault();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>CtClass cc = cp.get("Hello");</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>// 获取say方法</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>CtMethod m = cc.getDeclaredMethod("say");</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>// 在方法第一行前面插入代码</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>m.insertBefore("{ System.out.println(\"Hello.say():\"); }");</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Class c = cc.toClass();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Hello h = (Hello)c.newInstance();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>h.say();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>}</span><br /><span>}</span></p><p><span style="font-weight:bold">Test.main()</span><span> 在</span><span style="font-weight:bold">Hello</span><span>的</span><span style="font-weight:bold">say()</span><span> 方法的方法体中插入了</span><span style="font-weight:bold">println()</span><span> 的调用。然后构建了被修改后的</span><span style="font-weight:bold">Hello</span><span>的实例，然后调用了该实例的</span><span style="font-weight:bold">say()</span><span> 方法。</span></p><p><span>注意，上面这段程序有一个前提，就是</span><span style="font-weight:bold">Hello</span><span>类在调用</span><span style="font-weight:bold">toClass()</span><span> 之前没有被加载过。否则，在</span><span style="font-weight:bold">toClass()</span><span> 请求加载被修改后的</span><span style="font-weight:bold">Hello</span><span>类之前，JVM就会加载原始的</span><span style="font-weight:bold">Hello</span><span>类。因此，加载被修改后的</span><span style="font-weight:bold">Hello</span><span>类就会失败（抛出LinkageError）。例如:</span></p><p class="IndentedCode"><span>public static void main(String[] args) throws Exception {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>Hello orig = new Hello();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>ClassPool cp = ClassPool.getDefault();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>CtClass cc = cp.get("Hello");</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>Class c = cc.toClass();</span><span style="-aw-import:spaces">&#xa0; </span><span>// 这句会报错</span><br /><span>}</span></p><p><span style="font-weight:bold">main</span><span>函数的第一行加载了</span><span style="font-weight:bold">Hello</span><span>类，</span><span style="font-weight:bold">cc.toClass()</span><span> 这行就会抛出异常。原因是类加载器不能同时加载两个不同版本的</span><span style="font-weight:bold">Hello</span><span>类。</span></p><p><span>如果你的程序运行在JBOSS或Tomcat的应用服务器上，那么你再用</span><span style="font-weight:bold">toClass()</span><span> 就有点不合适了。这种情况下，将会抛出</span><span style="font-weight:bold">ClassCastException</span><span>异常。为了避免这个异常，你必须给</span><span style="font-weight:bold">toClass()</span><span> 一个合适的类加载器。例如，假设</span><span style="font-weight:bold">bean</span><span>是你的会话bean对象，那么这段代码：</span></p><p class="IndentedCode"><span>CtClass cc = ...;</span><br /><span>Class c = cc.toClass(bean.getClass().getClassLoader());</span></p><p><span>这段代码可以正常运行。你应该给</span><span style="font-weight:bold">toClass()</span><span> 的类加载器是加载你程序的加载器（上面的例子中，就是bean对象的class的类加载器）。</span></p><p><span style="font-weight:bold">toClass()</span><span> 已经很方便了。你要是想更复杂的类加载器，你应该自定义类加载器。</span></p><h3><span style="font-weight:normal">3.2 Java</span><span style="font-family:Calibri; font-weight:normal">中的类加载</span></h3><p><span>在Java中，多个类加载器可以共存，它们可以创建自己的命名空间。不同的类加载器能够加载有着相同类名的不同的类文件。被加载过的两个类会被视为不同的东西。这个特点可以让我们在一个JVM中运行多个应用程序，尽管它们包含了有着相同名称的不同的类。</span></p><p class="Quote"><span style="font-style:normal">JVM不允许动态重新加载一个类。一旦类加载加载过一个类之后，在运行期就不能在加载该类的另一个被修改过的版本。因此，你不能在JVM加载过一个类之后修改它的定义。但是，JPDA(Java Platform Debugger Architecture)提供了重新加载类的一些能力。详细请看3.6</span></p><p><span>如果两个不同的类加载器加载里一个相同的Class文件，那么JVM会生成两个不同的Class，虽然它们拥有相同的名字和定义。这两个Class会被视为两个不同的东西。因为这两个Class不是完全相同的，所以一个Class的实例不能赋值给另一个Class的变量。这两个类之间的类型转换会失败，抛出</span><span style="font-weight:bold">ClassCastException</span><span>异常。</span></p><p><span>例如，下面这个代码片段就会抛出该异常：</span></p><p class="IndentedCode"><span>MyClassLoader myLoader = new MyClassLoader();</span><br /><span>Class clazz = myLoader.loadClass("Box");</span><br /><span>Object obj = clazz.newInstance();</span><br /><span>Box b = (Box)obj;</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// 这里总是会抛出ClassCastException异常.</span></p><p><span style="font-weight:bold">Box</span><span>类被两个类加载器所加载。假定</span><span style="font-weight:bold">CL</span><span>类加载器加载了这段代码片段。因为该代码中引用了</span><span style="font-weight:bold">MyClassLoader</span><span>,</span><span style="font-weight:bold">Class</span><span>,</span><span style="font-weight:bold">Object</span><span>，所以</span><span style="font-weight:bold">CL</span><span>也会加载这些类(除非它代理了其它啊类加载器)。因此，</span><span style="font-weight:bold">b</span><span> 变量的类型是</span><span style="font-weight:bold">CL</span><span>加载的</span><span style="font-weight:bold">Box</span><span>。但是</span><span style="font-weight:bold">obj</span><span>变量的类型是</span><span style="font-weight:bold">myLoader</span><span>加载的</span><span style="font-weight:bold">Box</span><span>，虽然都是</span><span style="font-weight:bold">Box</span><span>，但是不一样。所以，最后一段代码一定会抛出</span><span style="font-weight:bold">ClassCastException</span><span>，因为</span><span style="font-weight:bold">b</span><span>和</span><span style="font-weight:bold">obj</span><span>是两个不同版本的</span><span style="font-weight:bold">Box</span><span>。</span></p><p><span>多个类加载形成了一个树型结构。除了启动加载器之外，其他的类加载器都有一个父类加载，子类加载器通常由父类加载器加载。由于加载类的请求可以沿着加载器的层次结构进行委托，所以你请求加载类的加载器，并不一定真的是由这个加载器加载的，也可能换其他加载器加载了。因此（举例），请求加载类</span><span style="font-weight:bold">C</span><span>的加载器可能不是真正加载类</span><span style="font-weight:bold">C</span><span>的加载器。不同的是，我们将前面的加载器称为</span><span style="font-weight:bold">C</span><span>的发起者（initiator），后面的加载器称为C实际的加载器(real loader)。</span></p><p><span>除此之外，如果类加载器</span><span style="font-weight:bold">CL</span><span>请求加载一个类</span><span style="font-weight:bold">C</span><span>（C的发起者）委托给了它的父类加载器</span><span style="font-weight:bold">PL</span><span>，那么类加载器</span><span style="font-weight:bold">CL</span><span>也不会加载类</span><span style="font-weight:bold">C</span><span>定义中引用的任何其他类。对于那些类，</span><span style="font-weight:bold">CL</span><span>不是它们的发起者，相反，父加载器</span><span style="font-weight:bold">PL</span><span>则会称为它们的发起者，并且回去加载它们。类</span><span style="font-weight:bold">C</span><span>定义中引用的类，由类C的实际的加载器去加载。</span></p><p><span>要理解上面的行为，可以参考下面代码：</span></p><p class="IndentedCode"><span>public class Point {</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// PL加载该类</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>private int x, y;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public int getX() { return x; }</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>:</span><br /><span>}</span><br /><br /><span>public class Box {</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>// L是发起者，但实际的加载器是PL</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>private Point upperLeft, size;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public int getBaseX() { return upperLeft.x; }</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>:</span><br /><span>}</span><br /><br /><span>public class Window {</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// 该类被加载器L加载</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>private Box box;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public int getBaseX() { return box.getBaseX(); }</span><br /><span>}</span></p><p><span>假定类加载器</span><span style="font-weight:bold">L</span><span>加载</span><span style="font-weight:bold">Window</span><span>类。加载</span><span style="font-weight:bold">Window</span><span>的发起者和实际加载者都是</span><span style="font-weight:bold">L</span><span>。因为</span><span style="font-weight:bold">Window</span><span>的定义引用了类</span><span style="font-weight:bold">Box</span><span>，所以JVM会让 </span><span style="font-weight:bold">L</span><span>去加载</span><span style="font-weight:bold">Box</span><span>类。这里，假定</span><span style="font-weight:bold">L</span><span>将该任务委托给了父类加载器</span><span style="font-weight:bold">PL</span><span>，所以加载</span><span style="font-weight:bold">Box</span><span>的发起者是</span><span style="font-weight:bold">L</span><span>，但实际加载者是</span><span style="font-weight:bold">PL</span><span>。这种情况下，</span><span style="font-weight:bold">PL</span><span>作为</span><span style="font-weight:bold">Box</span><span>的实际加载者，就会去加载</span><span style="font-weight:bold">Box</span><span>中定义中引用的</span><span style="font-weight:bold">Point</span><span>类，所以</span><span style="font-weight:bold">Point</span><span>的发起者和实际加载者都是</span><span style="font-weight:bold">PL</span><span>。因此加载器</span><span style="font-weight:bold">L</span><span>从来都没有请求过加载</span><span style="font-weight:bold">Point</span><span>类。</span></p><p><span>把上面的例子稍微改一下：</span></p><p class="IndentedCode"><span>public class Point {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>private int x, y;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public int getX() { return x; }</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>:</span><br /><span>}</span><br /><br /><span>public class Box {</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>// 发起者是L，但实际加载者是PL</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>private Point upperLeft, size;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public Point getSize() { return size; }</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>:</span><br /><span>}</span><br /><br /><span>public class Window {</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// Window由加载器L加载</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>private Box box;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public boolean widthIs(int w) {</span><span style="-aw-import:spaces">&#xa0; </span><span>// 增加了方法，方法中有对Point类的引用。</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Point p = box.getSize();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>return w == p.getX();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>}</span><br /><span>}</span></p><p><span>上面中，</span><span style="font-weight:bold">Window</span><span>也引用了</span><span style="font-weight:bold">Point</span><span>。这样，如果加载器</span><span style="font-weight:bold">L</span><span>需要加载</span><span style="font-weight:bold">Point</span><span>的话，</span><span style="font-weight:bold">L</span><span>也必须委托给</span><span style="font-weight:bold">PL</span><span>。</span><span style="font-style:italic">你必须避免让两个类加载器重复加载同一个类</span><span>。两个加载器中的一个必须委托给另一个加载器。</span></p><p><span>如果当</span><span style="font-weight:bold">Point</span><span>被加载时，</span><span style="font-weight:bold">L</span><span>没有委托给</span><span style="font-weight:bold">PL</span><span>，那么</span><span style="font-weight:bold">widthIs()就会抛出ClassCastException</span><span>。因为</span><span style="font-weight:bold">Window</span><span>里的</span><span style="font-weight:bold">Point</span><span>是</span><span style="font-weight:bold">L</span><span>加载的，而</span><span style="font-weight:bold">Box</span><span>中的</span><span style="font-weight:bold">Point</span><span>是</span><span style="font-weight:bold">PL</span><span>加载器加载的。你用</span><span style="font-weight:bold">box.getSize()</span><span> 返回的</span><span style="font-weight:bold">PL.Point</span><span>给</span><span style="font-weight:bold">L的Point</span><span>，那么就会JVM就会认为它们是不同的实例，进而抛出异常。</span></p><p><span>这样有些不方便，但是需要有这种限制。比如：</span></p><p class="IndentedCode"><span>Point p = box.getSize();</span></p><p><span>如果这条语句没有抛出异常，那么</span><span style="font-weight:bold">Window</span><span>的代码就有可能打破</span><span style="font-weight:bold">Point</span><span>的封装。例如，</span><span style="font-weight:bold">PL</span><span>加载的</span><span style="font-weight:bold">Point</span><span>的</span><span style="font-weight:bold">x</span><span>变量是private，但是</span><span style="font-weight:bold">L</span><span>加载器加载的</span><span style="font-weight:bold">Point</span><span>的</span><span style="font-weight:bold">x</span><span>变量是public(下面的代码定义)，那么不就打破了封装定义。</span></p><p class="IndentedCode"><span>public class Point {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public int x, y;</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// not private</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public int getX() { return x; }</span><br /><span>}</span></p><p><span>要是想了解更多关于JAVA类加载器的细节，可以参考下面这个论文：</span></p><p class="IndentedCode"><span>Sheng Liang and Gilad Bracha, "Dynamic Class Loading in the Java Virtual Machine", </span><br /><span>ACM OOPSLA'98, pp.36-44, 1998.</span></p><h3><span style="font-weight:normal">3.3 </span><span style="font-family:Calibri; font-weight:normal">使用</span><span style="font-weight:normal">javassist.Loader</span></h3><p><span>Javassist提供了一个类加载器</span><span style="font-weight:bold">javasist.Loader</span><span>，该加载器使用一个</span><span style="font-weight:bold">javassist.ClassPool</span><span>对象来读取类文件。</span></p><p><span>例如，</span><span style="font-weight:bold">javassist.Loader</span><span>可以加载一个被</span><span style="font-weight:bold">Javassist</span><span>修改过的特定类：</span></p><p class="IndentedCode"><span>import javassist.*;</span><br /><span>import test.Rectangle;</span><br /><br /><span>public class Main {</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>public static void main(String[] args) throws Throwable {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>ClassPool pool = ClassPool.getDefault();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Loader cl = new Loader(pool);</span><br /><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>CtClass ct = pool.get("test.Rectangle");</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>ct.setSuperclass(pool.get("test.Point"));</span><br /><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Class c = cl.loadClass("test.Rectangle");</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Object rect = c.newInstance();</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>}</span><br /><span>}</span></p><p><span>这段 程序修改了</span><span style="font-weight:bold">test.Rectangle</span><span>，将它的父类设置为了</span><span style="font-weight:bold">test.Point</span><span>。然后程序加载了修改后的类，并且创建了</span><span style="font-weight:bold">test.Rectangle</span><span>的一个新实例。</span></p><p><span>如果用户想根据需要在类被加载的时候修改类，那么用户可以增添一个事件监听器给</span><span style="font-weight:bold">javassist.Loader</span><span>。该事件监听器会在类加载器加载类时被通知。事件监听器必须实现下面这个接口：</span></p><p class="IndentedCode"><span>public interface Translator {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public void start(ClassPool pool)</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>throws NotFoundException, CannotCompileException;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public void onLoad(ClassPool pool, String classname)</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>throws NotFoundException, CannotCompileException;</span><br /><span>}</span></p><p><span>当使用</span><span style="font-weight:bold">javassist.Loader</span><span>的</span><span style="font-weight:bold">addTranslator()</span><span> 方法增添事件监听器时，</span><span style="font-weight:bold">start()</span><span> 方法就会被调用。在</span><span style="font-weight:bold">javassist.Loader</span><span>加载类之前，</span><span style="font-weight:bold">onLoad()</span><span> 方法就会被调用。你可以在</span><span style="font-weight:bold">onLoad()</span><span> 方法中修改要加载的类的定义。</span></p><p><span>例如，下面的事件监听器就在类被加载之前把它们都修改成public类。</span></p><p class="IndentedCode"><span>public class MyTranslator implements Translator {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>void start(ClassPool pool)</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>throws NotFoundException, CannotCompileException {}</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>void onLoad(ClassPool pool, String classname)</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>throws NotFoundException, CannotCompileException</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>{</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>CtClass cc = pool.get(classname);</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>cc.setModifiers(Modifier.PUBLIC);</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>}</span><br /><span>}</span></p><p><span>注意</span><span style="font-weight:bold">onLoad()不必调用toBytecode()或writeFile()</span><span>，因为</span><span style="font-weight:bold">javassist.Loader</span><span>会调用这些方法来获取类文件。</span></p><p><span>要想运行一个带有</span><span style="font-weight:bold">Mytranslator</span><span>对象的</span><span style="font-style:italic">application</span><span>(带main方法，可以运行的)类</span><span style="font-weight:bold">MyApp</span><span>，可以这样写：</span></p><p class="IndentedCode"><span>import javassist.*;</span><br /><br /><span>public class Main2 {</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>public static void main(String[] args) throws Throwable {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Translator t = new MyTranslator();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>ClassPool pool = ClassPool.getDefault();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Loader cl = new Loader();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>cl.addTranslator(pool, t);</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>cl.run("MyApp", args);</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>}</span><br /><span>}</span></p><p><span>然后这样运行这个程序：</span></p><p class="IndentedCode"><span>&gt; java Main2 arg1 arg2...</span></p><p><span>这样</span><span style="font-weight:bold">MyApp</span><span>和其他的应用程序类就会被</span><span style="font-weight:bold">MyTranslator</span><span>转换了。</span></p><p><span>注意，像</span><span style="font-weight:bold">MyApp</span><span>这样的应用类不能访问加载器的类，不如</span><span style="font-weight:bold">Main2</span><span>，</span><span style="font-weight:bold">MyTranslator</span><span>和</span><span style="font-weight:bold">ClassPool</span><span>。因为他们是被不同的加载器加载的。应用类时</span><span style="font-weight:bold">javassist.Loader</span><span>加载的，然而像</span><span style="font-weight:bold">Main2</span><span>这些是被默认的java类加载器加载的。</span></p><p><span style="font-weight:bold">javassist.Loader</span><span>搜索类的顺序和</span><span style="font-weight:bold">java.lang.ClassLoader.ClassLoader</span><span>不同。</span><span style="font-weight:bold">JavaClassLoader</span><span>首先会委托父加载器进行加载操作，父加载器找不到的时候，才会由子加载器加载。而</span><span style="font-weight:bold">javassist.Loader</span><span>首先尝试加载类，然后才会委托给父加载器。只有在下面这些情况才会进行委托：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>调用</span><span style="font-weight:bold">get()方法后在ClassPool</span><span>对象中找不到</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>使用</span><span style="font-weight:bold">delegateLoadingOf()</span><span> 方法指定要父类加载器去加载</span></p><p><span>这个搜索顺序机制允许</span><span style="font-weight:bold">Javassist</span><span>加载修改后的类。然而，如果它因为某些原因找不到修改后的类的话，就会委托父加载器去加载。一旦该类被父加载器加载，那么该类中引用的类也会用父加载器加载，并且它们不能再被修改了。回想下，之前类C的实际加载器加载了类C所有引用的类。如果你的程序加载一个修改过的类失败了，那么你就得想想是否那些类是否使用了被</span><span style="font-weight:bold">javassist.Loader</span><span>加载的类。</span></p><h3><span style="font-weight:normal">3.4 </span><span style="font-family:Calibri; font-weight:normal">自定义一个类加载器</span></h3><p><span>一个简单的类加载器如下：</span></p><p class="IndentedCode"><span>import javassist.*;</span><br /><br /><span>public class SampleLoader extends ClassLoader {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>/* Call MyApp.main().</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>*/</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public static void main(String[] args) throws Throwable {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>SampleLoader s = new SampleLoader();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Class c = s.loadClass("MyApp");</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>c.getDeclaredMethod("main", new Class[] { String[].class })</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>.invoke(null, new Object[] { args });</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>}</span><br /><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>private ClassPool pool;</span><br /><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public SampleLoader() throws NotFoundException {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>pool = new ClassPool();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>pool.insertClassPath("./class"); // MyApp.class must be there.</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>}</span><br /><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>/* Finds a specified class.</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>* The bytecode for that class can be modified.</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0; </span><span>*/</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>protected Class findClass(String name) throws ClassNotFoundException {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>try {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>CtClass cc = pool.get(name);</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>// modify the CtClass object here</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>byte[] b = cc.toBytecode();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>return defineClass(name, b, 0, b.length);</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>} catch (NotFoundException e) {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>throw new ClassNotFoundException();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>} catch (IOException e) {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>throw new ClassNotFoundException();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>} catch (CannotCompileException e) {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>throw new ClassNotFoundException();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>}</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>}</span><br /><span>}</span></p><p><span style="font-weight:bold">MyApp</span><span>是一个应用程序。要执行这段程序，首先要放一个class文件到 </span><span style="font-weight:bold">./class</span><span> 目录下，该目录不能包含在类搜索路径下。否则，</span><span style="font-weight:bold">MyApp.class</span><span>将会被默认的系统类加载器加载，也就是</span><span style="font-weight:bold">SampleLoader</span><span>的父类加载器。你也可以把</span><span style="font-weight:bold">insertClassPath</span><span>中的 </span><span style="font-weight:bold">./class</span><span> 放入构造函数的参数中，这样你就可以选择自己想要的路径了。 运行java程序：</span></p><p class="IndentedCode"><span>&gt; java SampleLoader</span></p><p><span>类加载器加载了类</span><span style="font-weight:bold">MyApp</span><span>(./class/MyApp.class)，并且调用了</span><span style="font-weight:bold">MyApp.main()</span><span> ，并传入了命令行参数。</span></p><p><span>这是使用Javassist最简单的方式。如果你想写个更复杂的类加载器，你可能需要更多的java类加载机制的知识。例如，上面的程序把</span><span style="font-weight:bold">MyApp</span><span>的命名空间和</span><span style="font-weight:bold">SampleLoader</span><span>的命名空间是分开的，因为它们两个类是由不同的类加载器加载的。因此，</span><span style="font-weight:bold">MyApp</span><span>不能直接访问</span><span style="font-weight:bold">SampleLoader</span><span>类。</span></p><h3><span style="font-weight:normal">3.5 </span><span style="font-family:Calibri; font-weight:normal">修改系统类</span></h3><p><span>除了系统类加载器，系统类不能被其他加载器加载，比如</span><span style="font-weight:bold">java.lang.String</span><span>。因此，上面的</span><span style="font-weight:bold">SampleLoader</span><span>和</span><span style="font-weight:bold">javassist.Loader</span><span>在加载期间不能修改系统类。</span></p><p><span>如果你的程序非要那么做，请“静态的”修改系统类。例如，下面的程序给</span><span style="font-weight:bold">java.lang.String</span><span>增添了</span><span style="font-weight:bold">hiddenValue</span><span>属性。</span></p><p class="IndentedCode"><span>ClassPool pool = ClassPool.getDefault();</span><br /><span>CtClass cc = pool.get("java.lang.String");</span><br /><span>CtField f = new CtField(CtClass.intType, "hiddenValue", cc);</span><br /><span>f.setModifiers(Modifier.PUBLIC);</span><br /><span>cc.addField(f);</span><br /><span>cc.writeFile(".");</span></p><p><span>这个程序会生成一个文件 </span><span style="font-weight:bold">./java/lang/String.class</span></p><p><span>用修改过的</span><span style="font-weight:bold">String</span><span>类运行一下你的程序</span><span style="font-weight:bold">MyApp</span><span>，按照下面：</span></p><p class="IndentedCode"><span>&gt; java -Xbootclasspath/p:. MyApp arg1 arg2...</span></p><p><span>假定</span><span style="font-weight:bold">MyApp</span><span>的代码是这样的：</span></p><p class="IndentedCode"><span>public class MyApp {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public static void main(String[] args) throws Exception {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>System.out.println(String.class.getField("hiddenValue").getName());</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>}</span><br /><span>}</span></p><p><span>如果被修改的</span><span style="font-weight:bold">String</span><span>正常加载的话，</span><span style="font-weight:bold">MyApp</span><span>就会打印</span><span style="font-weight:bold">hiddenValue</span><span>。</span></p><p class="Quote"><span style="font-style:normal">应用最好不要使用该技术去重写</span><span style="font-weight:bold; font-style:normal">rt.jar</span><span style="font-style:normal">中的内容，这样会违反Java 2 Runtime Environment binary code 协议。</span></p><h3><span style="font-weight:normal">3.6 </span><span style="font-family:Calibri; font-weight:normal">运行期重新加载一个类</span></h3><p><span>启动JVM时，如果开启了JPDA(Java Platform Debugger Architecture)，那么class就可以动态的重新加载了。在JVM加载一个类之后，旧的类可以被卸载，然后重新加载一个新版的类。意思就是，类的定义可以在运行期动态的修改。但是，新类一定要能和旧类相互兼容。JVM不允许两个版本存在模式的改变，它们需要有相同的方法和属性。</span></p><p><span style="font-weight:bold">Javassist</span><span>提供了一个很方便的类，用于在运行期改变类。想了解更多信息，可以看</span><span style="font-weight:bold">javassist.tools.HotSwapper</span><span>的API文档</span></p><h2><span style="font-family:Calibri; font-weight:normal; font-style:normal">四、内省</span><span style="font-weight:normal; font-style:normal">(introspection)</span><span style="font-family:Calibri; font-weight:normal; font-style:normal">和定制</span><span style="font-weight:normal; font-style:normal">(customization)</span></h2><h3><span style="font-family:Calibri; font-weight:normal">简介</span></h3><p><span style="font-weight:bold">CtClass</span><span> 提供了自省的方法。</span><span style="font-weight:bold">Javassist</span><span>的自省能力是能够兼容Java的反射API的。</span><span style="font-weight:bold">CtClass</span><span>提供了</span><span style="font-weight:bold">getName()</span><span>，</span><span style="font-weight:bold">getSuperclass()</span><span>，</span><span style="font-weight:bold">getMethods()</span><span> 等等方法。它也提供了修改类定义的方法。它允许增添一个新的属性，构造函数以及方法。甚至可以改变方法体。</span></p><p><span style="font-weight:bold">CtMethod</span><span>*对象代表一个方法。</span><span style="font-weight:bold">CtMethod</span><span>提供了一些修改方法定义的方法。注意，如果一个方法是从父类继承过来的，那么相同的 </span><span style="font-weight:bold">CtMethod</span><span>对象也会代表父类中声明的方法。</span><span style="font-weight:bold">CtMethod</span><span>对象会对应到每一个方法定义中。</span></p><p><span>例如，如果</span><span style="font-weight:bold">Point</span><span>类声明了</span><span style="font-weight:bold">move()</span><span> 方法，并且它的子类</span><span style="font-weight:bold">ColorPoint</span><span> 没有重写</span><span style="font-weight:bold">move()</span><span> 方法，那么</span><span style="font-weight:bold">Point</span><span>和</span><span style="font-weight:bold">ColorPoint</span><span>的</span><span style="font-weight:bold">move()</span><span> 方法会具有相同的</span><span style="font-weight:bold">CtMethod</span><span>对象。如果用</span><span style="font-weight:bold">CtMethod</span><span>修改了方法定义，那么该就该就会在两个类中都生效。如果你只想修改</span><span style="font-weight:bold">ColorPoint</span><span>中的</span><span style="font-weight:bold">move()</span><span> 方法，你必须要增添一个</span><span style="font-weight:bold">Point.move()</span><span> 方法的副本到</span><span style="font-weight:bold">ColorPoint</span><span>中去。可以使用</span><span style="font-weight:bold">CtNewethod.copy()</span><span> 来获取</span><span style="font-weight:bold">CtMethod</span><span>对象的副本。</span></p><p class="Quote"><span style="font-style:normal">Javassist不允许移除方法或者属性，但是允许你重命名它们。所以如果你不再需要方法或属性的时候，你应该将它们重命名或者把它们改成私有的，可以调用</span><span style="font-weight:bold; font-style:normal">CtMethod</span><span style="font-style:normal">的</span><span style="font-weight:bold; font-style:normal">setName()</span><span style="font-style:normal"> 和 </span><span style="font-weight:bold; font-style:normal">setModifiers()</span><span style="font-style:normal"> 来实现。</span></p><p><span>Javassist不允许给一个已经存在的方法增添额外的参数。如果你非要这么做，你可以增添一个同名的新方法，然后把这个参数增添到新方法中。例如，如果你想增添一个额外的</span><span style="font-weight:bold">int</span><span>参数给</span><span style="font-weight:bold">newZ</span><span> 方法：</span></p><p class="IndentedCode"><span>void move(int newX, int newY) { x = newX; y = newY; }</span></p><p><span>假设这个是在</span><span style="font-weight:bold">Point</span><span>类中的，那么你应该增添以下的代码到</span><span style="font-weight:bold">Point</span><span>中</span></p><p class="IndentedCode"><span>void move(int newX, int newY, int newZ) {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// do what you want with newZ.</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>move(newX, newY);</span><br /><span>}</span></p><p><span>Javassist也提供了一个底层API，用于直接编辑一个原生class文件。例如，</span><span style="font-weight:bold">CtClass</span><span>中的</span><span style="font-weight:bold">getClassFile</span><span>就会返回一个</span><span style="font-weight:bold">ClassFile</span><span>对象，它代表了一个原生Class文件。</span><span style="font-weight:bold">CtMethod</span><span>中的</span><span style="font-weight:bold">getMethodInfo()</span><span> 会返回一个</span><span style="font-weight:bold">MethodInfo</span><span>对象，它代表一个Class文件中的</span><span style="font-weight:bold">method_info</span><span>结构。底层API使用了JVM的一些特定词汇，用户需要了解class文件和字节码的一些知识。更多详情，可以参考第五章。</span></p><p><span>只要标识符是$开头的，那么在修改class文件的时候就需要</span><span style="font-weight:bold">javassist.runtime</span><span>包用于运行时支持。那些特定的标识符会在下面进行说明。要是没有标识符，可以不需要</span><span style="font-weight:bold">javassist.runtime</span><span>和其他的运行时支持包。更多详细内容，可以参考</span><span style="font-weight:bold">javassist.runtime</span><span>包的API文档。</span></p><h3><span style="font-weight:normal">4.1 </span><span style="font-family:Calibri; font-weight:normal">在方法的开头和结尾插入代码。</span></h3><p><span style="font-weight:bold">CtMethod</span><span>和</span><span style="font-weight:bold">CtConstructor</span><span>提供了</span><span style="font-weight:bold">insertBefore()</span><span>,</span><span style="font-weight:bold">insertAfter()</span><span>,</span><span style="font-weight:bold">addCatch()</span><span> 方法。它们被用于在已经存在的方法上面插入代码片段。用户可以把它们的代码以文本的形式写进去。Javassist包含了一个简单的编译器，可以处理这些源码文本。它能够把这些代码编译成字节码，然后将它们内嵌到方法体中。</span></p><p><span>往指定行插入代码也是有可能的（前提是class文件中包含行号表）。</span><span style="font-weight:bold">CtMethod</span><span>和</span><span style="font-weight:bold">CtConstructor</span><span>中的</span><span style="font-weight:bold">insertAt()</span><span> 就可以将代码插入指定行。它会编译代码文本，然后将其编译好的代码插入指定行。</span></p><p><span style="font-weight:bold">insertBefore()</span><span>,</span><span style="font-weight:bold">insertAfter()</span><span>,</span><span style="font-weight:bold">addCatch()</span><span>,</span><span style="font-weight:bold">insertAt()</span><span> 这些方法接受一个字符串来表示一个语句(statements)或代码块(block)。一句代码可以是一个控制结构，比如if、while，也可以是一个以分号(;)结尾的表达式。代码块是一组用 </span><span style="font-weight:bold">{}</span><span> 括起来的语句。因此，下面的每一行代码都是一个合法的语句或代码块。</span></p><p class="IndentedCode"><span>System.out.println("Hello");</span><br /><span>{ System.out.println("Hello"); }</span><br /><span>if (i &lt; 0) { i = -i; }</span></p><p><span>语句和代码块都可以引用属性或方法。如果方法使用 </span><span style="font-weight:bold">-g</span><span> 选项（class文件中包含局部变量）进行编译，它们也可以引用自己插入方法的参数。否则，它们只能通过特殊的变量 </span><span style="font-weight:bold">$0,$1,$2...</span><span> 来访问方法参数，下面有说明。虽然在代码块中声明一个新的局部变量是允许的，但是在方法中访问它们确是不允许的。然而，如果使用 </span><span style="font-weight:bold">-g</span><span> 选项进行编译， 就允许访问。</span></p><p><span>传递到</span><span style="font-weight:bold">insertBefore()</span><span>, </span><span style="font-weight:bold">insertAfter()</span><span> 等方法中的String字符串会被Javassist的编译器编译。因为该编译器支持语言扩展，所以下面的这些以$开头的标识符就具有了特殊意义：</span></p><table cellspacing="0" cellpadding="0" style="width:100%; margin-bottom:0pt; border:0.75pt solid #000000; -aw-border:0.5pt single; -aw-border-insideh:0.5pt single #000000; -aw-border-insidev:0.5pt single #000000; border-collapse:collapse"><tr><td style="border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single"><p style="font-size:11pt"><span>标识符</span></p></td><td style="border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single"><p style="text-align:center; font-size:11pt"><span>含义</span></p></td><td style="border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single"><p style="text-align:center; font-size:11pt"><span>英语含义</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$0, $1, $2, ...</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">this</span><span> 和实参</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">this</span><span> and actual parameters</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$args</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>参数数组。</span><span style="font-weight:bold">$args</span><span> 的类型是 </span><span style="font-weight:bold">Object[]</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>An array of parameters. The type of $args is Object[].</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$$</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>所有实参，例如m($$)等同于m($1,$2,...)</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>All actual parameters.For example, m($$) is equivalent to m($1,$2,...)</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$cflow(...)</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>cflow变量</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>cflow variable</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$r</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>返回值类型。用于强制类型转换表达式</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The result type. It is used in a cast expression.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$w</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>包装类型。用于强制类型转换表达式</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The wrapper type. It is used in a cast expression.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$_</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>结果值</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The resulting value</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$sig</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，表示参数类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>An array of java.lang.Class objects representing the formal parameter types.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$type</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，表示结果类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing the formal result type.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$class</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，表示当前被编辑的类</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing the class currently edited.</span></p></td></tr></table><p><span style="-aw-import:ignore">&#xa0;</span></p><h4><span style="font-weight:normal">4.1.1 $0, $1, $2, ...</span></h4><p><span>传递给目标方法的参数可以通过**$1,$2,...** 访问，而不是通过原先的参数名称。</span><span style="font-weight:bold">$1</span><span> 代表第一个参数，</span><span style="font-weight:bold">$2</span><span>代表第二个参数，以此类推。那些变量的类型和参数的类型是一样的。</span><span style="font-weight:bold">$0</span><span>代表</span><span style="font-weight:bold">this</span><span>，如果是静态方法的话，</span><span style="font-weight:bold">$0</span><span>不能用。</span></p><p><span>假定有一个</span><span style="font-weight:bold">Point</span><span>类如下：</span></p><p class="IndentedCode"><span>class Point {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>int x, y;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>void move(int dx, int dy) { x += dx; y += dy; }</span><br /><span>}</span></p><p><span>要想在调用</span><span style="font-weight:bold">move()</span><span> 时打印</span><span style="font-weight:bold">dx</span><span>和</span><span style="font-weight:bold">dy</span><span>的值，可以执行下面代码：</span></p><p class="IndentedCode"><span>ClassPool pool = ClassPool.getDefault();</span><br /><span>CtClass cc = pool.get("Point");</span><br /><span>CtMethod m = cc.getDeclaredMethod("move");</span><br /><span>m.insertBefore("{ System.out.println($1); System.out.println($2); }");</span><br /><span>cc.writeFile();</span></p><p><span>注意需要用 </span><span style="font-weight:bold">{}</span><span> 括起来，如果只有一行语句，可以不用括。</span></p><p><span>修改后的</span><span style="font-weight:bold">Point</span><span>类的定义长这个样子：</span></p><p class="IndentedCode"><span>class Point {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>int x, y;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>void move(int dx, int dy) {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>{ System.out.println(dx); System.out.println(dy); }</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>x += dx; y += dy;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>}</span><br /><span>}</span></p><p><span style="font-weight:bold">$1</span><span> 和 </span><span style="font-weight:bold">$2</span><span> 分别被</span><span style="font-weight:bold">dx</span><span>和</span><span style="font-weight:bold">dy</span><span>给替换了。</span></p><p><span style="font-weight:bold">$1, $2, $3</span><span> 是可以被更新的，如果它们被赋予了新值，那么它们对应的变量也会被赋予新值。</span></p><h4><span style="font-weight:normal">4.1.2 $args</span></h4><p><span>变量 </span><span style="font-weight:bold">$arg</span><span> 表示所有参数的一个数组。数组中的类型都是 </span><span style="font-weight:bold">Object</span><span> 。如果参数是基本数据类型比如</span><span style="font-weight:bold">int</span><span>，那么该参数就会被转换成包装类型比如</span><span style="font-weight:bold">java.lang.Integer</span><span>，然后存储到 </span><span style="font-weight:bold">$args</span><span>中。因此，</span><span style="font-weight:bold">$args[0]</span><span> 就等于 </span><span style="font-weight:bold">$1</span><span> ,除非它是个基本类型（int不等于Integer）。注意，</span><span style="font-weight:bold">$args[0]</span><span> 不等于 </span><span style="font-weight:bold">$0</span><span> 。 </span><span style="font-weight:bold">$0</span><span> 是</span><span style="font-weight:bold">this</span><span>。</span></p><p><span>如果一个 </span><span style="font-weight:bold">Object</span><span> 数组赋值给了 </span><span style="font-weight:bold">$args</span><span> , 那么参数的每一个元素都会一一赋值。如果某个参数是基本类型，那么相应的元素必须是包装类型。该值会从包装类型自动拆箱转换成基本数据类型。</span></p><h4><span style="font-weight:normal">4.1.3 $$</span></h4><p><span>$$ 是一个以逗号分隔参数的缩写。例如，如果</span><span style="font-weight:bold">move()</span><span> 方法的参数是3个。那么：</span></p><p class="IndentedCode"><span>move($$)</span></p><p><span>就等于：</span></p><p class="IndentedCode"><span>move($1, $2, $3)</span></p><p><span>如果</span><span style="font-weight:bold">move()</span><span> 没有接受任何参数，那么</span><span style="font-weight:bold">move($$)</span><span> 就等于</span><span style="font-weight:bold">move()</span><span> 。</span></p><p><span>$$ 也可以跟其他参数一起使用，比如你写这样一个表达式：</span></p><p class="IndentedCode"><span>exMove($$, context)</span></p><p><span>这个表达式就等通于下面：</span></p><p class="IndentedCode"><span>exMove($1, $2, $3, context)</span></p><p><span>$$ 能够支持泛型表示。一般与**$procced**一起使用，后面会说。</span></p><h4><span style="font-weight:normal">4.1.3 $cflow</span></h4><p><span style="font-weight:bold">$cflow</span><span> 意思就是控制流（control flow）。该只读变量返回特定方法进行递归调用时的深度。</span></p><p><span>假定</span><span style="font-weight:bold">CtMethod</span><span>实例</span><span style="font-weight:bold">cm</span><span>代表下面这个方法：</span></p><p class="IndentedCode"><span>int fact(int n) {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>if (n &lt;= 1)</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>return n;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>else</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>return n * fact(n - 1);</span><br /><span>}</span></p><p><span>要使用**$cflow**，首先要声明**$cflow</span><span style="font-weight:bold">要用于监控</span><span>fact()** 方法的调用。</span></p><p class="IndentedCode"><span>CtMethod cm = ...;</span><br /><span>cm.useCflow("fact");</span></p><p><span style="font-weight:bold">useCflow()</span><span> 的参数是声明**$cflow**变量的标识符。任何合法的Java名称都能作为标识符。因此标识符也可以包含点(.)。例如，</span><span style="font-weight:bold">my.Test.fact</span><span>就是一个合法的标识符。</span></p><p><span>那么，</span><span style="font-weight:bold">$cflow(fact)</span><span> 表示该方法递归调用时的深度。当该方法在方法内部递归调用时，第一次被调用时**$cflow(fact)** 的值是0而不是1。例如：</span></p><p class="IndentedCode"><span>cm.insertBefore("if ($cflow(fact) == 0)"</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>+ "</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>System.out.println(\"fact \" + $1);");</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></p><p><span>将</span><span style="font-weight:bold">fact</span><span>加入了显示参数的代码。因为**$cflow(face)** 被检查，所以如果在内部递归调用fact方法，则不会打印参数。</span></p><p><span>在当前线程的当前最顶层的堆栈帧下，</span><span style="font-weight:bold">$cflow</span><span>的值是</span><span style="font-weight:bold">cm</span><span>关联的指定方法的堆栈深度。</span><span style="font-weight:bold">$cflow</span><span>也能够在其他的方法下面访问。</span></p><h4><span style="font-weight:normal">4.1.4 $r</span></h4><p><span style="font-weight:bold">$r</span><span> 代表方法的返回值类型。他必须用于强制转换表达式中的转换类型。例如，这是它的一个典型用法：</span></p><p class="IndentedCode"><span>Object result = ... ;</span><br /><span>$_ = ($r)result;</span></p><p><span>如果返回值类型是一个基本数据类型，那么 </span><span style="font-weight:bold">($r)</span><span> 就会遵循特殊的语义。首先，如果被转换对象的类型就是基本类型，那么 </span><span style="font-weight:bold">($r)</span><span> 就会基本类型到基本类型的转换。但是，如果被转换对象的类型是包装类型，那么**$r</span><span style="font-weight:bold">就会从包装类型转为基本数据类型。例如，如果返回值类型为</span><span>int**，那 </span><span style="font-weight:bold">($r)</span><span> 就会将其从</span><span style="font-weight:bold">java.lang.Integer</span><span>转为</span><span style="font-weight:bold">int</span><span>。</span></p><p><span>如果返回值类型为</span><span style="font-weight:bold">void</span><span>，那么 </span><span style="font-weight:bold">($r)</span><span> 不会进行类型转换。 它什么都不做。然而，如果调用的方法返回值为</span><span style="font-weight:bold">void</span><span>的话，那么 </span><span style="font-weight:bold">($r)</span><span> 的结果就是</span><span style="font-weight:bold">null</span><span>。例如，如果</span><span style="font-weight:bold">foo()</span><span> 方法的返回值为</span><span style="font-weight:bold">void</span><span>，那么：</span></p><p class="IndentedCode"><span>$_ = ($r)foo();</span></p><p><span>这是一个合法语句。</span></p><p><span>类型转换符 </span><span style="font-weight:bold">($r)</span><span> 在</span><span style="font-weight:bold">return</span><span>语句中也是很有用的。即使返回值类型为</span><span style="font-weight:bold">void</span><span>，下面的</span><span style="font-weight:bold">return</span><span>语句也是合法的：</span></p><p class="IndentedCode"><span style="-aw-import:spaces">&#xa0;</span><span>return ($r)result;</span><br /><span> </span></p><p><span>这里，</span><span style="font-weight:bold">result</span><span>是某个本地变量。因为 </span><span style="font-weight:bold">($r)</span><span> 是</span><span style="font-weight:bold">void</span><span>的，所以返回值就被丢弃了。</span><span style="font-weight:bold">return</span><span>语句也被视为没有返回值，就等同于下面：</span></p><p class="IndentedCode"><span>return;</span></p><h4><span style="font-weight:normal">4.1.5 $w</span></h4><p><span style="font-weight:bold">$w</span><span> 表示一个包装类型。它必须用于强制类型转换表达式中。</span><span style="font-weight:bold">($w)</span><span> 把一个基本数据类型转换为包装类型。例如：</span></p><p class="IndentedCode"><span>Integer i = ($w)5;</span></p><p><span>所用的包装类型（Integer）取决于 </span><span style="font-weight:bold">($w)</span><span> 后面表达式的类型。如果表达式类型为</span><span style="font-weight:bold">double</span><span>，那么包装类型应为</span><span style="font-weight:bold">java.lang.Double</span><span>。</span></p><p><span>如果 </span><span style="font-weight:bold">($w)</span><span> 后面的表达式不是基本数据类型的话，那么 </span><span style="font-weight:bold">($w)</span><span> 将不起作用。</span></p><h4><span style="font-weight:normal">4.1.6 $_</span></h4><p><span style="font-weight:bold">CtMethod</span><span>和</span><span style="font-weight:bold">CtConstructor</span><span>中的</span><span style="font-weight:bold">insertAfter()</span><span> 在方法最后插入代码时，不只是 </span><span style="font-weight:bold">$1,$2..</span><span> 这些可以用，你也可用**$_**。</span></p><p><span style="font-weight:bold">$_</span><span> 表示方法的返回值。而该变量的类型取决于该方法的返回值类型。如果方法的返回值类型为</span><span style="font-weight:bold">void</span><span>，那么 </span><span style="font-weight:bold">$_的值是null</span><span>，类型为</span><span style="font-weight:bold">Object</span><span>。</span></p><p><span>只有方法不报错，运行正常的情况下，</span><span style="font-weight:bold">insertAfter()</span><span> 中的代码才会运行。如果你想让方法在抛出异常的时候也能执行</span><span style="font-weight:bold">insertAfter()</span><span> 中的代码，那你就把该方法的第二个参数</span><span style="font-weight:bold">asFinally</span><span>设置为true.</span></p><p><span>如果方法中抛出了异常，那么</span><span style="font-weight:bold">insertAfter()</span><span> 中的代码也会在</span><span style="font-weight:bold">finally</span><span>语句中执行。这时 </span><span style="font-weight:bold">$_</span><span> 的值是</span><span style="font-weight:bold">0</span><span>或</span><span style="font-weight:bold">null</span><span>。插入的代码执行完毕后，抛出的异常还会抛给原来的调用者。注意，**$_**的值不会抛给原来的调用者，它相当于没用了（抛异常的时候没有返回值）。</span></p><h4><span style="font-weight:normal">4.1.7 $sig</span></h4><p><span style="font-weight:bold">$sig</span><span>是一个</span><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，数组的内容是按找参数顺序，记录每个参数的类型。</span></p><h4><span style="font-weight:normal">4.1.8 $type</span></h4><p><span style="font-weight:bold">$type</span><span> 是一个</span><span style="font-weight:bold">java.lang.Class</span><span>对象，它表示返回值类型。如果是构造函数，则它是</span><span style="font-weight:bold">Void.class</span><span>的引用。</span></p><h4><span style="font-weight:normal">4.1.9 $class</span></h4><p><span style="font-weight:bold">$class</span><span> 值是 </span><span style="font-weight:bold">java.lang.Class</span><span> 对象，代表修改的方法所对应的那个类。</span><span style="font-weight:bold">$class</span><span> 是 </span><span style="font-weight:bold">$0</span><span> 的类型（$0是this）。</span></p><h4><span style="font-weight:normal">4.1.10 addCatch()</span></h4><p><span style="font-weight:bold">addCatch()</span><span> 往方法体插入了的代码片段会在方法抛出异常的时候执行。在源码中，你可以用**$e** 来表示抛出异常是的异常变量。</span></p><p><span>例如，这段代码：</span></p><p class="IndentedCode"><span>CtMethod m = ...;</span><br /><span>CtClass etype = ClassPool.getDefault().get("java.io.IOException");</span><br /><span>m.addCatch("{ System.out.println($e); throw $e; }", etype);</span></p><p><span>把</span><span style="font-weight:bold">m</span><span>代表的方法编译之后，就成了下面这样：</span></p><p class="IndentedCode"><span>try {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// 原本的代码</span><br /><span>}</span><br /><span>catch (java.io.IOException e) {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>System.out.println(e);</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>throw e;</span><br /><span>}</span></p><p><span>注意，插入的代码以</span><span style="font-weight:bold">throw</span><span>或</span><span style="font-weight:bold">return</span><span>语句结尾。</span></p><h3><span style="font-weight:normal">4.2 </span><span style="font-family:Calibri; font-weight:normal">修改方法体</span></h3><p><span style="font-weight:bold">CtMethod</span><span>和</span><span style="font-weight:bold">CtConstructor</span><span>提供了</span><span style="font-weight:bold">setBody()</span><span> 方法，该方法用于取代整个方法体。它们会把你提供的源码编译成字节码，然后完全替代之前方法的方法体。如果你传递的源码参数为</span><span style="font-weight:bold">null</span><span>，那么被替换的方法体只会包含一条</span><span style="font-weight:bold">return</span><span>语句。</span></p><p><span>在</span><span style="font-weight:bold">setBody()</span><span> 方法传递的源码中，以$开头的标识符会有一些特殊含义（这个跟上面是一样的）：</span></p><table cellspacing="0" cellpadding="0" style="width:100%; margin-bottom:0pt; border:0.75pt solid #000000; -aw-border:0.5pt single; -aw-border-insideh:0.5pt single #000000; -aw-border-insidev:0.5pt single #000000; border-collapse:collapse"><tr><td style="border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single"><p style="font-size:11pt"><span>标识符</span></p></td><td style="border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single"><p style="text-align:center; font-size:11pt"><span>含义</span></p></td><td style="border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single"><p style="text-align:center; font-size:11pt"><span>英语含义</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$0, $1, $2, ...</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">this</span><span> 和实参</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">this</span><span> and actual parameters</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$args</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>参数数组。</span><span style="font-weight:bold">$args</span><span> 的类型是 </span><span style="font-weight:bold">Object[]</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>An array of parameters. The type of $args is Object[].</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$$</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>所有实参，例如m($$)等同于m($1,$2,...)</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>All actual parameters.For example, m($$) is equivalent to m($1,$2,...)</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$cflow(...)</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>cflow变量</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>cflow variable</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$r</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>返回值类型。用于强制类型转换表达式</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The result type. It is used in a cast expression.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$w</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>包装类型。用于强制类型转换表达式</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The wrapper type. It is used in a cast expression.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$sig</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，表示参数类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>An array of java.lang.Class objects representing the formal parameter types.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$type</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，表示结果类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing the formal result type.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$class</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，表示当前被编辑的类</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing the class currently edited.</span></p></td></tr></table><p><span style="-aw-import:ignore">&#xa0;</span></p><p class="Quote"><span style="font-style:normal">注意，这里不能用 </span><span style="font-weight:bold; font-style:normal">$_</span><span style="font-style:normal"> 。</span></p><h3><span style="font-weight:normal">4.2.1 </span><span style="font-family:Calibri; font-weight:normal">修改现有的表达式</span></h3><p><span style="font-weight:bold">Javassist</span><span>允许只修改方法体中的某一个表达式。</span><span style="font-weight:bold">javassist.expr.ExprEditor</span><span>类用于替换方法体中的某一个表达式。用户可以定义</span><span style="font-weight:bold">ExprEditor</span><span>的子类来说明表达式应该如何被修改。</span></p><p><span>使用</span><span style="font-weight:bold">ExprEditor</span><span>对象，用户需要调用</span><span style="font-weight:bold">CtMethod</span><span>或</span><span style="font-weight:bold">CtClass</span><span>中的</span><span style="font-weight:bold">instrument()</span><span> 方法，例如：</span></p><p class="IndentedCode"><span>CtMethod cm = ... ;</span><br /><span>cm.instrument(</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>new ExprEditor() {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>public void edit(MethodCall m)</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>throws CannotCompileException</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>{</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>if (m.getClassName().equals("Point")</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>&amp;&amp; m.getMethodName().equals("move"))</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>m.replace("{ $1 = 0; $_ = $proceed($$); }");</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>}</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>});</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span></p><p><span>该功能为，搜索方法体中，所有对</span><span style="font-weight:bold">Point</span><span>类的</span><span style="font-weight:bold">move()</span><span> 方法的调用，都将其替换为如下代码块：</span></p><p class="IndentedCode"><span>{ $1 = 0; $_ = $proceed($$); }</span></p><p><span>因此，</span><span style="font-weight:bold">move()</span><span> 的第一个参数总是</span><span style="font-weight:bold">0</span><span>。注意，被替换的代码不是表达式，而是一个语句或代码块，并且不能包含try-catch。</span></p><p><span style="font-weight:bold">instrument()</span><span> 方法会搜索方法体。如果它找到了像是“方法调用、属性访问、对象创建”的表达式，那么它就会调用</span><span style="font-weight:bold">ExprEditor</span><span>对象的</span><span style="font-weight:bold">edit()</span><span> 方法。</span><span style="font-weight:bold">edit()</span><span> 的参数就代表了被找到的那个表达式。</span><span style="font-weight:bold">edit()</span><span> 方法可以通过该对象来检查和替换表达式。</span></p><p><span>调用</span><span style="font-weight:bold">MethodCall</span><span>对象</span><span style="font-weight:bold">m</span><span>的</span><span style="font-weight:bold">replace</span><span>方法来将其替换为一个语句或代码块。如果给了的是 </span><span style="font-weight:bold">{}</span><span>，那么该表达式就会从方法体中移除。如果你想在该表达式的前后加一些逻辑，你可以这样写：</span></p><p class="IndentedCode"><span>{ before-statements;</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>$_ = $proceed($$);</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>after-statements; }</span><br /><span style="-aw-import:spaces">&#xa0; </span></p><p><span>不管是方法调用，属性访问还是对象创建或者是其他，第二条语句都可以是：</span></p><p class="IndentedCode"><span>$_ = $proceed();</span></p><p><span>如果表达式是个读访问，或者：</span></p><p class="IndentedCode"><span>$proceed($$);</span></p><p><span>如果表达式是个写访问。</span></p><p><span>如果使用 </span><span style="font-weight:bold">-g</span><span> 选项编译源码，那么在</span><span style="font-weight:bold">replace()</span><span> 中也是可以直接使用局部变量的（前提是class文件中包含那个局部变量）。</span></p><h3><span style="font-weight:normal">4.2.2 javassist.expr.MethodCall</span></h3><p><span style="font-weight:bold">MethodCall</span><span>对象代表一个方法的调用。它的</span><span style="font-weight:bold">replace()</span><span> 方法会把方法调用替换成另一个语句或代码块。它接受一个源码文本来代表要替换的代码，文本中以$开头的表示符具有特殊的含义，就跟</span><span style="font-weight:bold">insertBefore()</span><span> 的差不多。</span></p><table cellspacing="0" cellpadding="0" style="width:100%; margin-bottom:0pt; border:0.75pt solid #000000; -aw-border:0.5pt single; -aw-border-insideh:0.5pt single #000000; -aw-border-insidev:0.5pt single #000000; border-collapse:collapse"><tr><td style="border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single"><p style="font-size:11pt"><span>标识符</span></p></td><td style="border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single"><p style="text-align:center; font-size:11pt"><span>含义</span></p></td><td style="border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single"><p style="text-align:center; font-size:11pt"><span>英语含义</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$0</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>方法调用的目标对象。&lt;br&gt;它不等于</span><span style="font-weight:bold">this</span><span>，它是调用方的</span><span style="font-weight:bold">this</span><span>对象。&lt;br&gt;如果是静态方法，</span><span style="font-weight:bold">$0</span><span> 是null.</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The target object of the method call.&lt;br&gt;This is not equivalent to this, which represents the caller-side this object.&lt;br&gt;$0 is null if the method is static.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$1, $2, ...</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>方法调用的参数</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The parameters of the method call.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$_</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>方法调用的返回值</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The resulting value of the method call.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$r</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>方法调用的返回值类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The result type of the method call.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$class</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象，表示声明该方法的类</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing the class declaring the method.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$sig</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，表示参数类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>An array of java.lang.Class objects representing the formal parameter types.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$type</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，表示结果类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing the formal result type.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$proceed</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>表达式中原始方法的名称</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The name of the method originally called in the expression.</span></p></td></tr></table><p><span style="-aw-import:ignore">&#xa0;</span></p><p><span>上面的“方法调用”的意思就是</span><span style="font-weight:bold">MethodCall</span><span>代表的那个对象。</span></p><p><span>其他的标识符，像 </span><span style="font-weight:bold">$w</span><span>，</span><span style="font-weight:bold">$args</span><span>，$$，也是可以用的。</span></p><p><span>除非返回类型是 </span><span style="font-weight:bold">void</span><span>，否则，代码文本中你必须要给**$</span><span style="font-style:italic">** 赋值，而且类型要对的上。如果返回类型是</span><span style="font-weight:bold; font-style:italic">void</span><span style="font-style:italic">，那么**$</span><span>** 的类型是**Object，你也不用给他赋值。</span></p><p><span style="font-weight:bold">$proceed</span><span>不是一个 </span><span style="font-weight:bold">String</span><span>，而是一个特殊的语法。它后面必须跟一个被括号 </span><span style="font-weight:bold">()</span><span> 包围的参数列表。</span></p><h4><span style="font-weight:normal">4.2.3 javassist.expr.ConstructorCall</span></h4><p><span style="font-weight:bold">ConstructorCall</span><span>对象代表一个构造函数的调用，像</span><span style="font-weight:bold">this()</span><span> ，并且</span><span style="font-weight:bold">super()</span><span> 包含在该构造方法体中。</span><span style="font-weight:bold">ConstructorCall</span><span>的</span><span style="font-weight:bold">replace()</span><span> 方法可以将一句语句或代码块替换掉原本的构造方法体。它接受源码文本代表要替换的代码，它之中的以$开头的标识符具有一些特殊含义，就行</span><span style="font-weight:bold">insertBefore</span><span>的那样：</span></p><table cellspacing="0" cellpadding="0" style="width:100%; margin-bottom:0pt; border:0.75pt solid #000000; -aw-border:0.5pt single; -aw-border-insideh:0.5pt single #000000; -aw-border-insidev:0.5pt single #000000; border-collapse:collapse"><tr><td style="border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single"><p style="font-size:11pt"><span>标识符</span></p></td><td style="border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single"><p style="text-align:center; font-size:11pt"><span>含义</span></p></td><td style="border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single"><p style="text-align:center; font-size:11pt"><span>英语含义</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$0</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>构造方法调用的目标对象。它就等于</span><span style="font-weight:bold">this</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The target object of the constructor call. This is equivalent to this.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$1, $2, ...</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>构造方法调用的参数</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The parameters of the constructor call.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$class</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象，表示声明该构造函数的类</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing the class declaring the constructor.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$sig</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，表示参数类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>An array of java.lang.Class objects representing the formal parameter types.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$proceed</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>表达式中原始方法的名称</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The name of the method originally called in the expression.</span></p></td></tr></table><p><span style="-aw-import:ignore">&#xa0;</span></p><p><span>这里，“构造函数调用”的意思就是</span><span style="font-weight:bold">ConstructorCall</span><span>对象代表的那个方法。</span></p><p><span>**$w,$args,$$**等标识符也是可以用的</span></p><p><span>因为任何构造函数都要调用它的父类构造函数或是自己其他的构造函数，所以被替换的语句要包含一个构造函数的调用，通用使用**$proceed()**.</span></p><p><span style="font-weight:bold">$proceed</span><span>不是一个</span><span style="font-weight:bold">String</span><span>，而是一个特殊的语法。它后面必须跟一个被括号 </span><span style="font-weight:bold">()</span><span> 包围的参数列表。</span></p><h4><span style="font-weight:normal">4.2.4 javassist.expr.FieldAccess</span></h4><p><span style="font-weight:bold">FieldAccess</span><span>对象代表属性访问。如果找到了属性访问，那么</span><span style="font-weight:bold">ExprEditor</span><span>的</span><span style="font-weight:bold">edit()</span><span> 就会接收到。</span><span style="font-weight:bold">FieldAccesss</span><span>的</span><span style="font-weight:bold">replace()</span><span> 方法接受一个源码文本，用于替换原本属性访问的代码。</span></p><p><span>在源码文本中，以$的标识符具有一些特殊的含义：</span></p><table cellspacing="0" cellpadding="0" style="width:100%; margin-bottom:0pt; border:0.75pt solid #000000; -aw-border:0.5pt single; -aw-border-insideh:0.5pt single #000000; -aw-border-insidev:0.5pt single #000000; border-collapse:collapse"><tr><td style="border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single"><p style="font-size:11pt"><span>标识符</span></p></td><td style="border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single"><p style="text-align:center; font-size:11pt"><span>含义</span></p></td><td style="border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single"><p style="text-align:center; font-size:11pt"><span>英语含义</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$0</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>包含该变量的那个对象。&lt;br&gt;它不等与</span><span style="font-weight:bold">this</span><span>，</span><span style="font-weight:bold">this</span><span>是访问该变量的那个方法对应的类对象。&lt;br&gt;如果变量为静态变量，</span><span style="font-weight:bold">$0</span><span>为null</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The object containing the field accessed by the expression. This is not equivalent to this.&lt;br&gt;this represents the object that the method including the expression is invoked on.&lt;br&gt;$0 is null if the field is static.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$1</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>如果表达式是写访问，那么它代表将要被写入的值。&lt;br&gt;否则**$1**不可用</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The value that would be stored in the field if the expression is write access. &lt;br&gt;Otherwise, $1 is not available.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$_</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>如果表达式是读访问，它代表读取到的值。&lt;br&gt;否则，存储在**$_的值将丢失。</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The resulting value of the field access if the expression is read access. &lt;br&gt;Otherwise, the value stored in $_ is discarded.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$r</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>如果表达式是读访问，它代表变量的类型。&lt;br&gt;否则，</span><span style="font-weight:bold">$r</span><span>是</span><span style="font-weight:bold">void</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The type of the field if the expression is read access. &lt;br&gt;Otherwise, $r is void.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$class</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象，表示声明该属性的类</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing the class declaring the field.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$type</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，表示该变量的</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing the field type.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$proceed</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>表达式中原始方法的名称</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The name of a virtual method executing the original field access. .</span></p></td></tr></table><p><span style="-aw-import:ignore">&#xa0;</span></p><p><span>**$w,$args,$$**等标识符也是可以用的。</span></p><p><span>如果表达式是读访问，必须要在源码文本中给**$_**赋值，而且类型要对的上。</span></p><h4><span style="font-weight:normal">4.2.5 javassist.expr.NewExpr</span></h4><p><span style="font-weight:bold">NewExpr</span><span>对象表示使用</span><span style="font-weight:bold">new</span><span>关键字创建新对象（不包括数组创建）。如果找到了对象时，</span><span style="font-weight:bold">ExprEditor</span><span>的</span><span style="font-weight:bold">edit()</span><span> 方法就会被执行。可以使用</span><span style="font-weight:bold">NewExpr</span><span>的</span><span style="font-weight:bold">replace()</span><span> 方法来替换原本的代码。</span></p><p><span>在源代码文本中，以$开头的标识符具有特殊含义：</span></p><table cellspacing="0" cellpadding="0" style="width:100%; margin-bottom:0pt; border:0.75pt solid #000000; -aw-border:0.5pt single; -aw-border-insideh:0.5pt single #000000; -aw-border-insidev:0.5pt single #000000; border-collapse:collapse"><tr><td style="border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single"><p style="font-size:11pt"><span>标识符</span></p></td><td style="border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single"><p style="text-align:center; font-size:11pt"><span>含义</span></p></td><td style="border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single"><p style="text-align:center; font-size:11pt"><span>英语含义</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$0</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>null</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>null</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$1,$2,...</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>构造器的参数</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The parameters to the constructor.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$_</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>创建对象的结果值。新创建的对象必须存储到这个变量中。</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The resulting value of the object creation. &lt;br&gt;A newly created object must be stored in this variable.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$r</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>创建对象的类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The type of the created object.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$sig</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，表示参数类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>An array of java.lang.Class objects representing the formal parameter types.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$type</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象，表示创建对象的那个类的类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>java.lang.Class object representing the class of the created object.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$proceed</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>表达式中原始方法的名称</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The name of a virtual method executing the original object creation. .</span></p></td></tr></table><p><span style="-aw-import:ignore">&#xa0;</span></p><p><span>**$w,$args,$$**等标识符也是可以用的。</span></p><h4><span style="font-weight:normal">4.2.6 javassist.expr.NewArray</span></h4><p><span style="font-weight:bold">NewArray</span><span>代表</span><span style="font-weight:bold">new</span><span>关键字创建数组。如果找到了数组的创建， </span><span style="font-weight:bold">ExprEditor</span><span>的</span><span style="font-weight:bold">edit()</span><span> 方法就会被执行。</span><span style="font-weight:bold">NewArray</span><span>的</span><span style="font-weight:bold">replace()</span><span> 方法能够替换创建数组的代码。</span></p><p><span>在源代码文本里，以$开头的标识符有以下特殊含义：</span></p><table cellspacing="0" cellpadding="0" style="width:100%; margin-bottom:0pt; border:0.75pt solid #000000; -aw-border:0.5pt single; -aw-border-insideh:0.5pt single #000000; -aw-border-insidev:0.5pt single #000000; border-collapse:collapse"><tr><td style="border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single"><p style="font-size:11pt"><span>标识符</span></p></td><td style="border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single"><p style="text-align:center; font-size:11pt"><span>含义</span></p></td><td style="border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single"><p style="text-align:center; font-size:11pt"><span>英语含义</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$0</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>null</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>null</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$1,$2,...</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>每个维度的大小</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The size of each dimension.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$_</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>数组创建的返回值。新创建的数组必须要存到该变量中</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The resulting value of the array creation. &lt;br&gt;A newly created array must be stored in this variable.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$r</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>被创建的数组的类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The type of the created array.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$sig</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象的数组，表示参数类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>An array of java.lang.Class objects representing the formal parameter types.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$type</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象，表示被创建的数组的类</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing the class of the created array.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$proceed</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>表达式中原始方法的名称</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The name of a virtual method executing the original array creation.</span></p></td></tr></table><p><span style="-aw-import:ignore">&#xa0;</span></p><p><span>**$w,$args,$$**等标识符也是可以用的。</span></p><p><span>例如，如果按照下面的方式创建数组：</span></p><p class="IndentedCode"><span>String[][] s = new String[3][4];</span></p><p><span>那么**$1</span><span style="font-weight:bold">和</span><span>$2</span><span style="font-weight:bold">的值分别是</span><span>3</span><span style="font-weight:bold">和</span><span>4**，</span><span style="font-weight:bold">$3</span><span>不可用。</span></p><p><span>如果数组是按照下面的方式创建的：</span></p><p class="IndentedCode"><span>String[][] s = new String[3][];</span></p><p><span style="font-weight:bold">$1</span><span>的值是</span><span style="font-weight:bold">3</span><span>，</span><span style="font-weight:bold">$2</span><span>不可用。</span></p><h4><span style="font-weight:normal">4.2.7 javassist.expr.Instanceof</span></h4><p><span style="font-weight:bold">Instanceof</span><span>对象代表了一个</span><span style="font-weight:bold">instanceof</span><span>语句。如果</span><span style="font-weight:bold">instanceof</span><span>语句被发现，</span><span style="font-weight:bold">ExprEditor</span><span>的</span><span style="font-weight:bold">edit()</span><span> 就会被执行。</span><span style="font-weight:bold">Instanceof</span><span>的</span><span style="font-weight:bold">replace()</span><span> 方法会替换它原本的代码。</span></p><p><span>在源代码文本中，以$开头的标识符具有特殊的含义：</span></p><table cellspacing="0" cellpadding="0" style="width:100%; margin-bottom:0pt; border:0.75pt solid #000000; -aw-border:0.5pt single; -aw-border-insideh:0.5pt single #000000; -aw-border-insidev:0.5pt single #000000; border-collapse:collapse"><tr><td style="border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single"><p style="font-size:11pt"><span>标识符</span></p></td><td style="border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single"><p style="text-align:center; font-size:11pt"><span>含义</span></p></td><td style="border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single"><p style="text-align:center; font-size:11pt"><span>英语含义</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$0</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>null</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>null</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$1</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>instanceof操作符左边变量的值</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The value on the left hand side of the original instanceof operator.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$_</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>表达式的结果值。</span><span style="font-weight:bold">$_</span><span> 的类型为</span><span style="font-weight:bold">boolean</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The resulting value of the expression. The type of $_ is boolean.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$r</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>instanceof操作符右边的类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The type on the right hand side of the instanceof operator.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$type</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象，表示instanceof操作符右边的类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing the type on the right hand side of the instanceof operator.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$proceed</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>表达式中原始方法的名称。&lt;br&gt;它接受一个参数(类型为</span><span style="font-weight:bold">java.lang.Object</span><span>)。&lt;br&gt;如果类型对的上，返回true，否则为false</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The name of a virtual method executing the original instanceof expression. &lt;br&gt;It takes one parameter (the type is java.lang.Object) and returns true &lt;br&gt;if the parameter value is an instance of the type on the right hand side of &lt;br&gt;the original instanceof operator. Otherwise, it returns false.</span></p></td></tr></table><p><span style="-aw-import:ignore">&#xa0;</span></p><p><span>**$w,$args,$$**等标识符也是可以用的。</span></p><h4><span style="font-weight:normal">4.2.8 javassist.expr.Cast</span></h4><p><span style="font-weight:bold">Cast</span><span>对象代表一个强制类型转换表达式。如果找到了强制类型转换的表达式，</span><span style="font-weight:bold">ExprEditor</span><span>的</span><span style="font-weight:bold">edit()</span><span> 方法将会被执行。</span><span style="font-weight:bold">Cast</span><span>的</span><span style="font-weight:bold">replace()</span><span> 方法会替换原来的代码。</span></p><p><span>在源代码文本里，以$开头的标识符有以下特殊含义：</span></p><table cellspacing="0" cellpadding="0" style="width:100%; margin-bottom:0pt; border:0.75pt solid #000000; -aw-border:0.5pt single; -aw-border-insideh:0.5pt single #000000; -aw-border-insidev:0.5pt single #000000; border-collapse:collapse"><tr><td style="border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single"><p style="font-size:11pt"><span>标识符</span></p></td><td style="border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single"><p style="text-align:center; font-size:11pt"><span>含义</span></p></td><td style="border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single"><p style="text-align:center; font-size:11pt"><span>英语含义</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$0</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>null</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>null</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$1</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>被类型转换的那个变量的值</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The value the type of which is explicitly cast.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$_</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>表达式结果的值。</span><span style="font-weight:bold">$_的类型是被强制转换后的类型，就是()</span><span> 包起来的那个。</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The resulting value of the expression. The type of $_ is the same as the type &lt;br&gt;after the explicit casting, that is, the type surrounded by </span><span style="font-weight:bold">()</span><span>.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$r</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>被强制转换后的类型，或者说是被 </span><span style="font-weight:bold">()</span><span> 包起来的那个类型。</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>the type after the explicit casting, or the type surrounded by </span><span style="font-weight:bold">()</span><span> .</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$type</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象，表示与**$r**相同的那个类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing the same type as $r.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$proceed</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>表达式中原始方法的名称。&lt;br&gt;他接受一个</span><span style="font-weight:bold">java.lang.Object</span><span>类型的参数，并在强制转换成功后返回它。</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The name of a virtual method executing the original type casting. &lt;br&gt;It takes one parameter of the type java.lang.Object and returns it after &lt;br&gt;the explicit type casting specified by the original expression.</span></p></td></tr></table><p><span style="-aw-import:ignore">&#xa0;</span></p><p><span style="font-weight:bold">$w,$args,$$</span><span> 等标识符也是可以用的。</span></p><h4><span style="font-weight:normal">4.2.9 javassist.expr.Handler</span></h4><p><span style="font-weight:bold">Handler</span><span>对象代表了</span><span style="font-weight:bold">try-catch</span><span>语句中的</span><span style="font-weight:bold">catch</span><span>语句。如果找到了</span><span style="font-weight:bold">catch</span><span>语句，</span><span style="font-weight:bold">edit()</span><span> 方法就会被执行。</span><span style="font-weight:bold">Handler</span><span>的</span><span style="font-weight:bold">insertBefore()</span><span> 可以在</span><span style="font-weight:bold">catch</span><span>语句的最开始插入代码。</span></p><p><span>在源代码文本中，以$开头的标识符具有特殊的含义：</span></p><table cellspacing="0" cellpadding="0" style="width:100%; margin-bottom:0pt; border:0.75pt solid #000000; -aw-border:0.5pt single; -aw-border-insideh:0.5pt single #000000; -aw-border-insidev:0.5pt single #000000; border-collapse:collapse"><tr><td style="border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single"><p style="font-size:11pt"><span>标识符</span></p></td><td style="border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single"><p style="text-align:center; font-size:11pt"><span>含义</span></p></td><td style="border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single"><p style="text-align:center; font-size:11pt"><span>英语含义</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$1</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">catch</span><span>语句捕获的异常对象</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The exception object caught by the catch clause.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$r</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>捕获异常的异常类型。用于强制类型转换</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>the type of the exception caught by the catch clause. It is used in a cast expression.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$w</span></p></td><td style="border-style:solid; border-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border:0.5pt single"><p style="text-align:center; font-size:11pt"><span>包装类型，用于强制类型转换</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; border-bottom-style:solid; border-bottom-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-bottom:0.5pt single; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>The wrapper type. It is used in a cast expression.</span></p></td></tr><tr><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="font-size:11pt"><span>$type</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-right-style:solid; border-right-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-right:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span style="font-weight:bold">java.lang.Class</span><span>对象，表示catch捕获的异常对象的类型</span></p></td><td style="border-top-style:solid; border-top-width:0.75pt; border-left-style:solid; border-left-width:0.75pt; padding-right:5.03pt; padding-left:5.03pt; vertical-align:top; -aw-border-left:0.5pt single; -aw-border-top:0.5pt single"><p style="text-align:center; font-size:11pt"><span>A java.lang.Class object representing &lt;br&gt;the type of the exception caught by the catch clause.</span></p></td></tr></table><p><span style="-aw-import:ignore">&#xa0;</span></p><p><span>如果给 </span><span style="font-weight:bold">$1</span><span> 赋了新的异常对象，它会将其作为捕获异常传递给原始的 </span><span style="font-weight:bold">catch</span><span> 语句。</span></p><h3><span style="font-weight:normal">4.3 </span><span style="font-family:Calibri; font-weight:normal">增加新方法或新属性</span></h3><h4><span style="font-weight:normal">4.3.1 增加新方法</span></h4><p><span>Javassist允许用户从零开始创建一个新的方法和构造函数。</span><span style="font-weight:bold">CtNewMethod</span><span>和</span><span style="font-weight:bold">CtNewConstructor</span><span>提供了几个工厂方法，它们都是静态方法用于创建</span><span style="font-weight:bold">CtMethod</span><span>或</span><span style="font-weight:bold">CtConstructor</span><span>对象。尤其是</span><span style="font-weight:bold">make()</span><span> 方法，它可以直接传递源代码，用于创建</span><span style="font-weight:bold">CtMethod</span><span>和</span><span style="font-weight:bold">CtConstructor</span><span>对象。</span></p><p><span>例如这个程序：</span></p><p class="IndentedCode"><span>CtClass point = ClassPool.getDefault().get("Point");</span><br /><span>CtMethod m = CtNewMethod.make(</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>"public int xmove(int dx) { x += dx; }",</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>point);</span><br /><span>point.addMethod(m);</span></p><p><span>该代码给</span><span style="font-weight:bold">Point</span><span>类增添了一个</span><span style="font-weight:bold">public</span><span>方法</span><span style="font-weight:bold">xmove()</span><span> 。其中</span><span style="font-weight:bold">x</span><span>是</span><span style="font-weight:bold">Point</span><span>类原本就有的一个</span><span style="font-weight:bold">int</span><span>属性。</span></p><p><span>传递给</span><span style="font-weight:bold">make()</span><span> 的代码也可以包含以 $ 开头的标识符，就跟</span><span style="font-weight:bold">setBody()</span><span> 方法是一样的，除了**$_** 之外。如果你还把</span><span style="font-weight:bold">make()</span><span> 传递了目标对象和目标方法，你也可以使用**$proceed**。 例如：</span></p><p class="IndentedCode"><span>CtClass point = ClassPool.getDefault().get("Point");</span><br /><span>CtMethod m = CtNewMethod.make(</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>"public int ymove(int dy) { $proceed(0, dy); }",</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>point, "this", "move");</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></p><p><span>这个程序创建的</span><span style="font-weight:bold">ymove()</span><span> 的定义如下：</span></p><p class="IndentedCode"><span>public int ymove(int dy) { this.move(0, dy); }</span></p><p><span>这里面</span><span style="font-weight:bold">this.move</span><span>替换了**$proceed**。</span></p><p><span>Javassist还提供了一些其他方法用于创建新方法。你可以先创建一个抽象方法，之后再给它一个方法体:</span></p><p class="IndentedCode"><span>CtClass cc = ... ;</span><br /><span>CtMethod m = new CtMethod(CtClass.intType, "move",</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>new CtClass[] { CtClass.intType }, cc);</span><br /><span>cc.addMethod(m);</span><br /><span>m.setBody("{ x += $1; }");</span><br /><span>cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span></p><p><span>你给class增添过抽象方法之后，Javassist就会把这个类变成抽象类，所以在你调用</span><span style="font-weight:bold">setBody()</span><span> 方法后，需要显式的把该class改变成非抽象类。</span></p><h4><span style="font-weight:normal">4.3.2 相互递归方法</span></h4><p><span>如果一个类没有增添某一个方法，那么Javassist是不允许调用它的。（但是Javassist编译自己调用自己的递归方法）。要给一个类增添相互递归的方法，你需要先增添一个抽象方法。假定你向增添</span><span style="font-weight:bold">m()</span><span> 和 </span><span style="font-weight:bold">n()</span><span> 方法到</span><span style="font-weight:bold">cc</span><span>代表的类中。</span></p><p class="IndentedCode"><span>CtClass cc = ... ;</span><br /><span>CtMethod m = CtNewMethod.make("public abstract int m(int i);", cc);</span><br /><span>CtMethod n = CtNewMethod.make("public abstract int n(int i);", cc);</span><br /><span>cc.addMethod(m);</span><br /><span>cc.addMethod(n);</span><br /><span>m.setBody("{ return ($1 &lt;= 0) ? 1 : (n($1 - 1) * $1); }");</span><br /><span>n.setBody("{ return m($1); }");</span><br /><span>cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span></p><p><span>你必须首先把它们弄成两个抽象方法，然后增添到class中。然后你就能给他们增加方法体，方法体中也可以进行互相调用。最后你必须把类改成非抽象类，因为你</span><span style="font-weight:bold">addMethod()</span><span> 的时候，javassist自动把该类改成了抽象类。</span></p><h4><span style="font-weight:normal">4.3.3 增添属性</span></h4><p><span>Javassist也允许用户创建一个新的属性：</span></p><p class="IndentedCode"><span>CtClass point = ClassPool.getDefault().get("Point");</span><br /><span>CtField f = new CtField(CtClass.intType, "z", point);</span><br /><span>point.addField(f);</span></p><p><span>这个程序给</span><span style="font-weight:bold">Point</span><span>类增添一个名为</span><span style="font-weight:bold">z</span><span>的属性。</span></p><p><span>如果增添的属性需要进行值初始化，则上面的程序就要改成这样：</span></p><p class="IndentedCode"><span>CtClass point = ClassPool.getDefault().get("Point");</span><br /><span>CtField f = new CtField(CtClass.intType, "z", point);</span><br /><span>point.addField(f, "0");</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// 初始化的值是0.</span></p><p><span>Now，</span><span style="font-weight:bold">addField()</span><span> 方法接受了第二个参数，它代表了计算初始值表达式的源码文本。该源码文本可以是任何Java表达式，前提是表达式的结果类型和属性类型匹配。注意，表达式不以分号(;)结尾，意思就是</span><span style="font-weight:bold">0</span><span>后面不用跟分号。</span></p><p><span>除此之外，上面的代码也可用下面这个简单的代码代替：</span></p><p class="IndentedCode"><span>CtClass point = ClassPool.getDefault().get("Point");</span><br /><span>CtField f = CtField.make("public int z = 0;", point);</span><br /><span>point.addField(f);</span></p><h4><span style="font-weight:normal">4.3.4 删除属性</span></h4><p><span>要删除属性或方法，可以调用</span><span style="font-weight:bold">CtClass</span><span>中的</span><span style="font-weight:bold">removeField()</span><span> 或 </span><span style="font-weight:bold">removeMethod()</span><span>。也可以调用</span><span style="font-weight:bold">removeConstructor()</span><span> 删除构造函数。</span></p><h3><span style="font-weight:normal">4.4 </span><span style="font-family:Calibri; font-weight:normal">注解</span></h3><p><span style="font-weight:bold">CtClass, CtMethod, CtField, CtConstructor</span><span> 提供了一个很方便的方法</span><span style="font-weight:bold">getAnnotations()</span><span> 来读取注解。它返回一个注解类型对象。</span></p><p><span>例如，假定下列注解：</span></p><p class="IndentedCode"><span>public @interface Author {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>String name();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>int year();</span><br /><span>}</span></p><p><span>这个注解被这样使用：</span></p><p class="IndentedCode"><span>@Author(name="Chiba", year=2005)</span><br /><span>public class Point {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>int x, y;</span><br /><span>}</span></p><p><span>那么，这个注解的值可以通过</span><span style="font-weight:bold">getAnnotations()</span><span> 方法获取。它返回一个包含了注解类型对象的数组：</span></p><p class="IndentedCode"><span>CtClass cc = ClassPool.getDefault().get("Point");</span><br /><span>Object[] all = cc.getAnnotations();</span><br /><span>Author a = (Author)all[0];</span><br /><span>String name = a.name();</span><br /><span>int year = a.year();</span><br /><span>System.out.println("name: " + name + ", year: " + year);</span></p><p><span>这段代码的输出是：</span></p><p class="IndentedCode"><span>name: Chiba, year: 2005</span></p><p><span>因为</span><span style="font-weight:bold">Point</span><span>只包含了 </span><span style="font-weight:bold">@Author</span><span> 一个注解，所以 </span><span style="font-weight:bold">all</span><span> 数组的长度是1，</span><span style="font-weight:bold">all[0]</span><span> 是</span><span style="font-weight:bold">Author</span><span>对象。该注解的属性值可以使用</span><span style="font-weight:bold">Author</span><span>对象的</span><span style="font-weight:bold">name()</span><span> 和 </span><span style="font-weight:bold">year()</span><span> 方法获取。</span></p><p><span>要使用</span><span style="font-weight:bold">getAnnotation()</span><span>, 当前class路径下必须要包含注解类型，像</span><span style="font-weight:bold">Author</span><span>。</span><span style="font-style:italic">它们也必须在ClassPool对象中可访问</span><span>。如果注解类型的Class文件没有找到，Javassist就不能获取该注解类型成员的默认值。</span></p><h3><span style="font-weight:normal">4.5 </span><span style="font-family:Calibri; font-weight:normal">运行时类支持</span></h3><p><span>大多数情况下，由Javassist修改的类不需要Javassist去运行。然而，有些Javassist编译器生成的字节码需要运行时类支持，那些都在</span><span style="font-weight:bold">javassist.runtime</span><span>包中（详细内容请参考该包的API文档）。注意，</span><span style="font-weight:bold">javassist.runtime</span><span>包只负责管Javassist修改的类的运行时支持。其他Javassist修改后的类不会在运行时使用。</span></p><h3><span style="font-weight:normal">4.6 Import</span></h3><p><span>源码中所有的类名都必须是完全限定的（它们必须导入包名）。然而，</span><span style="font-weight:bold">java.lang</span><span>包时一个特例；例如，</span><span style="font-weight:bold">Javassist</span><span>编译器可以解析</span><span style="font-weight:bold">Object</span><span>也可以解析</span><span style="font-weight:bold">java.lang.Object</span><span>.</span></p><p><span>为了告知编译器当解析类时搜索其他的包，可以调用</span><span style="font-weight:bold">ClassPool</span><span>的</span><span style="font-weight:bold">importPackage()</span><span> 方法。 例如：</span></p><p class="IndentedCode"><span>ClassPool pool = ClassPool.getDefault();</span><br /><span>pool.importPackage("java.awt");</span><br /><span>CtClass cc = pool.makeClass("Test");</span><br /><span>CtField f = CtField.make("public Point p;", cc);</span><br /><span>cc.addField(f);</span></p><p><span>第二行告诉编译器要导入</span><span style="font-weight:bold">java.awt</span><span>包。因此，第三行不会抛出异常。编译器会把</span><span style="font-weight:bold">Point</span><span>看作</span><span style="font-weight:bold">java.awt.Point</span><span>.</span></p><p><span>注意，</span><span style="font-weight:bold">importPackage()</span><span> 不会影响</span><span style="font-weight:bold">ClassPool</span><span>的</span><span style="font-weight:bold">get()</span><span> 方法。只有编译器会任务导入了包。</span><span style="font-weight:bold">get()</span><span> 方法的参数必须总是全限定名。</span></p><h3><span style="font-weight:normal">4.7 </span><span style="font-family:Calibri; font-weight:normal">局限性</span></h3><p><span>在当前实现中，Javassist的编译器存在几个局限性。这些局限性有：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>J2SE 5.0中提到的语法（包括枚举和泛型）还没有得到支持。注解由Javassist的底层API支持。参见</span><span style="font-weight:bold">javassist.bytecode.annotation</span><span>包（和</span><span style="font-weight:bold">getAnnotations()</span><span> 以及</span><span style="font-weight:bold">CtBehavior</span><span> ）。泛型也只是部分支持。后面的章节有详细介绍。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>数组初始化的时候，以逗号分割，大括号 </span><span style="font-weight:bold">{}</span><span> 包围的初始化方式还不支持。除非数组的长度时1.</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>不支持内部类和匿名类。注意，这只是编译器的局限。它不能编译包含在匿名类定义中的源码。Javassist可以读取并修改内部/匿名类的类文件。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>不支持</span><span style="font-weight:bold">continue</span><span>和</span><span style="font-weight:bold">break</span><span>关键字。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>编译器不能正确的实现Java方法的多态。如果方法在一个类中具有相同的名字，但是却有不同的参数列表，编译器可能会出错。例如：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:' '; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="-aw-import:spaces">&#xa0;</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>class A {}</span><br /><span>class B extends A {}</span><br /><span>class C extends B {}</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:' '; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'; -aw-import:spaces">&#xa0;</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>class X {</span><br /><span>void foo(A a) { .. }</span><br /><span>void foo(B b) { .. }</span><br /><span>}</span></p><p><span>如果被编译的表达式是</span><span style="font-weight:bold">x.foo(new C())</span><span>, </span><span style="font-weight:bold">x</span><span>是</span><span style="font-weight:bold">X</span><span>的一个实例，编译器可能会生成一个对</span><span style="font-weight:bold">foo(A)</span><span> 的调用，虽然编译器可以正确的编译</span><span style="font-weight:bold">foo((B)new C())</span><span>.</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>建议用户使用 </span><span style="font-weight:bold">#</span><span> 作为类名与静态方法或属性之间的分给。例如，在Java中：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:' '; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="-aw-import:spaces">&#xa0;</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>javassist.CtClass.intType.getName()</span></p><p><span>在javassist.CtClass中的静态字段intType指示的对象上调用getName()方法。在Javassist中，用户可以写上面的表达式，但是还是建议按照下面这样写：</span></p><p class="IndentedCode"><span>javassist.CtClass#intType.getName()</span></p><p><span>这样，编译器就可以很快的解析这个表达式。</span></p><h2><span style="font-family:Calibri; font-weight:normal; font-style:normal">五、字节码</span><span style="font-weight:normal; font-style:normal">API</span></h2><p><span style="font-weight:bold">由于我没有字节码知识基础，所以本章的翻译可能会有很多不准的地方。</span></p><h3><span style="font-family:Calibri; font-weight:normal">简介</span></h3><p><span>Javassist也提供了底层API用于直接编辑class文件。要使用了该API，你需要Java字节码和class文件格式的详细知识，这样你就可以利用API对class文件想怎么改就怎么改。</span></p><p><span>如果你只想生成一个简单的class文件，你可以使用</span><span style="font-weight:bold">javassist.bytecode.ClassFileWriter</span><span>。它比</span><span style="font-weight:bold">javassist.bytecode.ClassFile</span><span>快的多，虽然它的API最小。</span></p><h3><span style="font-weight:normal">5.1 </span><span style="font-family:Calibri; font-weight:normal">获取 </span><span style="font-weight:normal">ClassFile </span><span style="font-family:Calibri; font-weight:normal">对象</span></h3><p><span>一个</span><span style="font-weight:bold">javassist.bytecode.ClassFile</span><span>对象代表一个Class文件。可以使用</span><span style="font-weight:bold">CtClass</span><span>中的</span><span style="font-weight:bold">getClassFile()</span><span> 获取该对象。</span></p><p><span>除此之外，你也可以用根据一个Class文件直接构造该</span><span style="font-weight:bold">javassist.bytecode.ClassFile</span><span>对象。例如：</span></p><p class="IndentedCode"><span>BufferedInputStream fin</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>= new BufferedInputStream(new FileInputStream("Point.class"));</span><br /><span>ClassFile cf = new ClassFile(new DataInputStream(fin));</span></p><p><span>该代码片段创建了一个来自</span><span style="font-weight:bold">Point.class</span><span>的</span><span style="font-weight:bold">ClassFile</span><span>对象。</span></p><p><span>你也可以从零开始创建一个新文件。例如：</span></p><p class="IndentedCode"><span>ClassFile cf = new ClassFile(false, "test.Foo", null);</span><br /><span>cf.setInterfaces(new String[] { "java.lang.Cloneable" });</span><br /><span> </span><br /><span>FieldInfo f = new FieldInfo(cf.getConstPool(), "width", "I");</span><br /><span>f.setAccessFlags(AccessFlag.PUBLIC);</span><br /><span>cf.addField(f);</span><br /><br /><span>cf.write(new DataOutputStream(new FileOutputStream("Foo.class")));</span></p><p><span>该代码生成了一个class文件</span><span style="font-weight:bold">Foo.class</span><span>，它包含了以下实现：</span></p><p class="IndentedCode"><span>package test;</span><br /><span>class Foo implements Cloneable {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>public int width;</span><br /><span>}</span></p><h3><span style="font-weight:normal">5.2 </span><span style="font-family:Calibri; font-weight:normal">增添或删除成员</span></h3><p><span style="font-weight:bold">ClassFile</span><span>提供了</span><span style="font-weight:bold">addField()</span><span> 和</span><span style="font-weight:bold">addMethod()</span><span> ，用于增添属性或方法（注意在字节码中，构造函数被视为一个方法）。它也提供了</span><span style="font-weight:bold">addAttribute()</span><span> 用于增添一个属性到class文件中。</span></p><p><span>注意，</span><span style="font-weight:bold">FiledInfo</span><span>, </span><span style="font-weight:bold">MethodInfo</span><span> 和 </span><span style="font-weight:bold">AttributeInfo</span><span> 对象包含了对</span><span style="font-weight:bold">ConstPool</span><span>(常量池表)对象的引用。</span><span style="font-weight:bold">ConstPool</span><span>对象必须是</span><span style="font-weight:bold">ClassFile</span><span>对象和被增添到</span><span style="font-weight:bold">ClassFile</span><span>对象的</span><span style="font-weight:bold">FieldInfo</span><span>（或</span><span style="font-weight:bold">MethodInfo</span><span>等）的公共对象。换句话说，一个</span><span style="font-weight:bold">FieldInfo</span><span>(或</span><span style="font-weight:bold">MethodInfo</span><span>等)对象不能在不同的</span><span style="font-weight:bold">ClassFile</span><span>对象之间共享。</span></p><p><span>要从</span><span style="font-weight:bold">ClassFile</span><span>对象中移除一个属性或方法，你必须先获取该类所有属性的</span><span style="font-weight:bold">java.util.List</span><span>，可以使用</span><span style="font-weight:bold">getField()</span><span> 和</span><span style="font-weight:bold">getMethod()</span><span> ，它们都返回list。属性和方法都可以使用该</span><span style="font-weight:bold">List</span><span>对象的</span><span style="font-weight:bold">remove()</span><span> 方法进行移除。一个属性(Attribute)可以通过相同的方法进行移除。调用</span><span style="font-weight:bold">FieldInfo</span><span>或</span><span style="font-weight:bold">MethodInfo</span><span>的</span><span style="font-weight:bold">getAttribute()</span><span> 来获取属性列表，然后从返回的list中移除它。</span></p><h3><span style="font-weight:normal">5.3 </span><span style="font-family:Calibri; font-weight:normal">遍历方法体</span></h3><p><span>要检查方法体中的每个字节码指令，</span><span style="font-weight:bold">CodeIterator</span><span>是很有用的。要获取这个对象，可以这样做：</span></p><p class="IndentedCode"><span>ClassFile cf = ... ;</span><br /><span>MethodInfo minfo = cf.getMethod("move");</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// we assume move is not overloaded.</span><br /><span>CodeAttribute ca = minfo.getCodeAttribute();</span><br /><span>CodeIterator i = ca.iterator();</span></p><p><span style="font-weight:bold">CodeIterator</span><span>对象可以让你从开头到结尾一行一行的访问每一个字节码指令。下面是</span><span style="font-weight:bold">CodeIterator</span><span>一部分的方法API:</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span style="font-weight:bold">void begin()</span><span> ： 移动到第一个指令</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span style="font-weight:bold">void move(int index)</span><span>：移动到指定index位置的指令</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span style="font-weight:bold">boolean hasNext()</span><span>：如果还有指令，则返回true</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span style="font-weight:bold">int next()</span><span>：返回下一个指令的index。注意，他不会返回下一个指令的字节码。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span style="font-weight:bold">int byteAt(int index)</span><span>: 返回该位置的无符号8bit(unsigned 8bit)值</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span style="font-weight:bold">int u16bitAt(int index)</span><span>: 返回该位置的无符号16bit（unsigned 16bit）值。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span style="font-weight:bold">int write(byte[] code, int index)</span><span>: 在该位置写byte数组。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span style="font-weight:bold">void insert(int index, byte[] code)</span><span>，在该位置插入byte数组。分支偏移量等会自动调节。</span></p><p class="Quote"><span style="font-style:normal">这里我不是很会翻译，可以直接看原版</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>void begin()</span><br /><span>&lt;br&gt;Move to the first instruction.</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>void move(int index)</span><br /><span>&lt;br&gt;Move to the instruction specified by the given index.</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>boolean hasNext()</span><br /><span>&lt;br&gt;Returns true if there is more instructions.</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>int next()</span><br /><span>&lt;br&gt;Returns the index of the next instruction.</span><br /><span>&lt;br&gt;Note that it does not return the opcode of the next instruction.</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>int byteAt(int index)</span><br /><span>&lt;br&gt;Returns the unsigned 8bit value at the index.</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>int u16bitAt(int index)</span><br /><span>&lt;br&gt;Returns the unsigned 16bit value at the index.</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>int write(byte[] code, int index)</span><br /><span>&lt;br&gt;Writes a byte array at the index.</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'-'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">-</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>void insert(int index, byte[] code)</span><br /><span>&lt;br&gt;Inserts a byte array at the index. Branch offsets etc. are automatically adjusted.</span></p><p><span>下面这段代码基本包含了上面所介绍的所有API:</span></p><p class="IndentedCode"><span>CodeIterator ci = ... ;</span><br /><span>while (ci.hasNext()) {</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>int index = ci.next();</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>int op = ci.byteAt(index);</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>System.out.println(Mnemonic.OPCODE[op]);</span><br /><span>}</span></p><h3><span style="font-weight:normal">5.4 </span><span style="font-family:Calibri; font-weight:normal">生成字节码序列</span></h3><p><span style="font-weight:bold">Bytecode</span><span>对象代表一串字节码指令。它是一个可增长的</span><span style="font-weight:bold">bytecode</span><span>数组。例如：</span></p><p class="IndentedCode"><span>ConstPool cp = ...;</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>// constant pool table</span><br /><span>Bytecode b = new Bytecode(cp, 1, 0);</span><br /><span>b.addIconst(3);</span><br /><span>b.addReturn(CtClass.intType);</span><br /><span>CodeAttribute ca = b.toCodeAttribute();</span></p><p><span>这将生产代码属性，表示以下字节码序列：</span></p><p class="IndentedCode"><span>iconst_3</span><br /><span>ireturn</span></p><p><span>你也可以调用</span><span style="font-weight:bold">Bytecode</span><span>中的</span><span style="font-weight:bold">get()</span><span> 方法获取包含该序列的byte数组。获取到的数组可以插入到其他的代码属性中。</span></p><p><span style="font-weight:bold">Bytecode</span><span>提供了一些方法来增添特定的指令到字节码序列中。它提供了</span><span style="font-weight:bold">addOpcode()</span><span> 用于增添8bit操作码，也提供了</span><span style="font-weight:bold">addIndex()</span><span> 方法用于增添一个索引。每个操作码的8bit值都被定义在</span><span style="font-weight:bold">Opcode</span><span>接口中。</span></p><p><span style="font-weight:bold">addOpcode()</span><span> 和其他用于增添特殊指令的方法，是自动维护最大堆栈深度，除非控制流不包括分支。可以通过</span><span style="font-weight:bold">Bytecode</span><span>对象的</span><span style="font-weight:bold">getMaxStack()</span><span> 值获取。它也会在</span><span style="font-weight:bold">Bytecode</span><span>对象构造的</span><span style="font-weight:bold">CodeAttribute</span><span>对象上反应出来。要重新计算方法体的堆栈深度，调用</span><span style="font-weight:bold">CodeAttribute</span><span>的</span><span style="font-weight:bold">computeMaxStack()</span><span> 方法。</span></p><p><span style="font-weight:bold">Bytecode</span><span>可以用于构造方法，例如：</span></p><p class="IndentedCode"><span>ClassFile cf = ...</span><br /><span>Bytecode code = new Bytecode(cf.getConstPool());</span><br /><span>code.addAload(0);</span><br /><span>code.addInvokespecial("java/lang/Object", MethodInfo.nameInit, "()V");</span><br /><span>code.addReturn(null);</span><br /><span>code.setMaxLocals(1);</span><br /><br /><span>MethodInfo minfo = new MethodInfo(cf.getConstPool(), MethodInfo.nameInit, "()V");</span><br /><span>minfo.setCodeAttribute(code.toCodeAttribute());</span><br /><span>cf.addMethod(minfo);</span></p><p><span>这段代码创建了默认的构造函数，然后将其增添到了</span><span style="font-weight:bold">cf</span><span>指定的class中。</span><span style="font-weight:bold">Bytecode</span><span>对象首先被转换成了</span><span style="font-weight:bold">CodeAttribute</span><span>对象，然后增添到了</span><span style="font-weight:bold">minfo</span><span>指定的方法中。该方法最终被增添到了</span><span style="font-weight:bold">cf</span><span>类文件中。</span></p><h3><span style="font-weight:normal">5.5 </span><span style="font-family:Calibri; font-weight:normal">注解（</span><span style="font-weight:normal">Meta tags</span><span style="font-family:Calibri; font-weight:normal">）</span></h3><p><span>注解作为运行时不可见（或可见）的注解属性被存储在class文件中。它们的属性可以通过</span><span style="font-weight:bold">ClassFile</span><span>,</span><span style="font-weight:bold">MethodInfo</span><span>或</span><span style="font-weight:bold">FieldInfo</span><span>对象获取，调用那些对象的</span><span style="font-weight:bold">getAttribute(AnnotationsAttribute.invisibleTag)</span><span> 方法。 更详细的内容参见</span><span style="font-weight:bold">javassist.bytecode.AnnotationsAttribute</span><span> 和</span><span style="font-weight:bold">javassist.bytecode.annotation</span><span>包的javadoc手册。</span></p><p><span>Javassist也让你通过顶层API访问注解。如果你想通过</span><span style="font-weight:bold">CtClass</span><span>访问注解，可以调用</span><span style="font-weight:bold">getAnnotations()</span><span> 方法。</span></p><h2><span style="font-family:Calibri; font-weight:normal; font-style:normal">六、泛型</span></h2><p><span style="font-weight:bold">Javassist</span><span>的底层API完全支持了Java5中的泛型。另一方面，顶层API，例如 </span><span style="font-weight:bold">CtClass</span><span>， 不能直接支持泛型。然而，这个对于字节码转换不是一个严重的问题。</span></p><p><span>Java中的泛型是通过消除技术实现的。 在编译之后，所有的类型参数都将消失。例如，假定你的源码声明了一个参数化的类型 </span><span style="font-weight:bold">Vector&lt;String</span><span> :</span></p><p class="IndentedCode"><span>Vector&lt;String&gt; v = new Vector&lt;String&gt;();</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>:</span><br /><span>String s = v.get(0);</span></p><p><span>编译后的字节码就等同于下面：</span></p><p class="IndentedCode"><span>Vector v = new Vector();</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>:</span><br /><span>String s = (String)v.get(0);</span></p><p><span>所以当你写一个字节码转换器时，你可以删除所有的类型参数。因为被嵌在Javassist中的编译器不支持泛型，所以对于使用Javassis插入的代码，你必须插入一个显式的类型转换。例如通过 </span><span style="font-weight:bold">CtMethod.make()</span><span> 插入的代码。如果源码是被正常的Java编译器编译的话，比如javac，你就不需要做类型转换了。</span></p><p><span>例如，如果你有这么一个类：</span></p><p class="IndentedCode"><span>public class Wrapper&lt;T&gt; {</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>T value;</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>public Wrapper(T t) { value = t; }</span><br /><span>}</span></p><p><span>你想增添一个接口 </span><span style="font-weight:bold">Getter&lt;T&gt;</span><span> 到类 </span><span style="font-weight:bold">Wrapper&lt;T&gt;</span><span> 中：</span></p><p class="IndentedCode"><span>public interface Getter&lt;T&gt; {</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>T get();</span><br /><span>}</span></p><p><span>那么你真正增添的是 </span><span style="font-weight:bold">Getter</span><span> (类型参数&lt;T&gt;被丢弃了)，并且你必须向 </span><span style="font-weight:bold">Wrapper</span><span> 类增添的方法就是下面这样一个简单的方法：</span></p><p class="IndentedCode"><span>public Object get() { return value; }</span></p><p><span>注意，不需要类型参数。因为 </span><span style="font-weight:bold">get</span><span> 返回的是 </span><span style="font-weight:bold">Object</span><span> ,所以在调用方需要显示的增加类型转换。例如，如果类型参数</span><span style="font-weight:bold">T</span><span>是</span><span style="font-weight:bold">String</span><span>, 那么 </span><span style="font-weight:bold">(String)</span><span> 必须像下面这样被插入：</span></p><p class="IndentedCode"><span>Wrapper w = ...</span><br /><span>String s = (String)w.get();</span></p><p><span>如果编译器是正常的Java编译器，那么不需要显式的指定类型转换，它会自动插入类型转换代码。</span></p><h2><span style="font-family:Calibri; font-weight:normal; font-style:normal">七、可变参数</span><span style="font-weight:normal; font-style:normal">(int... args)</span></h2><p><span>目前，Javassist不直接支持可变参数。所以要让一个方法拥有可变参数，你必须显式的设置方法修饰符。但是这是容易的。假定现在你想创建下面的这个方法：</span></p><p class="IndentedCode"><span>public int length(int... args) { return args.length; }</span></p><p><span>上面的代码使用Javassist可以这样创建：</span></p><p class="IndentedCode"><span>CtClass cc = /* target class */;</span><br /><span>CtMethod m = CtMethod.make("public int length(int[] args) { return args.length; }", cc);</span><br /><span>m.setModifiers(m.getModifiers() | Modifier.VARARGS);</span><br /><span>cc.addMethod(m);</span></p><p><span>参数类型 </span><span style="font-weight:bold">int...</span><span> 被变成了 </span><span style="font-weight:bold">int[]</span><span> , 并且 </span><span style="font-weight:bold">Modifier.VARARGS</span><span> 被增添到了方法修饰符中。</span></p><p><span>要在</span><span style="font-weight:bold">Javassist</span><span>中的源码文本中调用该方法，你必须这样写：</span></p><p class="IndentedCode"><span>length(new int[] { 1, 2, 3 });</span></p><p><span>不能使用Java原生的调用方式：</span></p><p class="IndentedCode"><span>length(1, 2, 3);</span></p><h2><span style="font-family:Calibri; font-weight:normal; font-style:normal">八、</span><span style="font-weight:normal; font-style:normal">J2ME</span></h2><p><span>如果你要修改的文件是J2ME环境的，那么你必须执行预校验。预校验是生成堆栈映射（stack map）的基础，它与JDK1.6中的堆栈映射表很像。只有</span><span style="font-weight:bold">javassist.bytecode.MethodInfo.doPreverify</span><span>为true的时候，Javassist才会为J2ME维护堆栈映射。</span></p><p><span>你也可以手工的为修改的方法生成一个堆栈映射。比如下面这个，</span><span style="font-weight:bold">m</span><span> 是一个 </span><span style="font-weight:bold">CtMethod</span><span> 对象，你可以调用下面方法来生成一个堆栈映射：</span></p><p class="IndentedCode"><span>m.getMethodInfo().rebuildStackMapForME(cpool);</span></p><p><span>这里， </span><span style="font-weight:bold">cpool</span><span> 是一个 </span><span style="font-weight:bold">ClassPool</span><span> 对象， 可以通过调用</span><span style="font-weight:bold">CtClass</span><span>的 </span><span style="font-weight:bold">getClassPool()</span><span> 方法获取。</span><span style="font-weight:bold">ClassPool</span><span> 对象负责从给定路径找到class文件，这个前面章节已经说过了。要获取所有的</span><span style="font-weight:bold">CtMethod</span><span>对象，可以调用</span><span style="font-weight:bold">CtClass</span><span>的</span><span style="font-weight:bold">getDeclaredMethods</span><span>方法。</span></p><h2><span style="font-family:Calibri; font-weight:normal; font-style:normal">九、拆箱和装箱</span></h2><p><span>Java中的拆箱和装箱是个语法糖。是没有字节码的。所以Javassist的编译器不支持它们。例如，下面这个语句在Java中是合法的：</span></p><p class="IndentedCode"><span>Integer i = 3;</span></p><p><span>因为装箱是暗中执行。 对于Javassist来说，然而，你必须显式的将</span><span style="font-weight:bold">int</span><span>转换为</span><span style="font-weight:bold">Integer</span><span>：</span></p><p class="IndentedCode"><span>Integer i = new Integer(3);</span></p><h2><span style="font-family:Calibri; font-weight:normal; font-style:normal">十、</span><span style="font-weight:normal; font-style:normal">Debug</span></h2><p><span>把 </span><span style="font-weight:bold">CtClass.debugDump</span><span> 的值设置成一个目录，那么Javassist修改和生成的所有class文件都将会被保存在该目录下。要是不想弄，把 </span><span style="font-weight:bold">CtClass.debugDump</span><span> 设置为null就行了。默认值也是null。</span></p><p><span>例如：</span></p><p class="IndentedCode"><span>CtClass.debugDump = "./dump";</span></p><p><span>Javassist修改的所有class文件都将存储在 </span><span style="font-weight:bold">./dump</span><span> 目录下。</span></p></div></body></html>
